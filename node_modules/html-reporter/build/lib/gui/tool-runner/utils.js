"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterByEqualDiffSizes = exports.prepareLocalDatabase = exports.mergeDatabasesForReuse = exports.mkFullTitle = exports.formatId = void 0;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const chalk_1 = __importDefault(require("chalk"));
const common_utils_1 = require("../../common-utils");
const constants_1 = require("../../constants");
const server_1 = require("../../db-utils/server");
const migrations_1 = require("../../db-utils/migrations");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('html-reporter:gui:tool-runner:utils');
const formatId = (hash, browserId) => `${hash}/${browserId}`;
exports.formatId = formatId;
const mkFullTitle = ({ suite, state }) => {
    return suite.path.length > 0 ? `${suite.path.join(' ')} ${state.name}` : state.name;
};
exports.mkFullTitle = mkFullTitle;
const mergeDatabasesForReuse = async (reportPath) => {
    const dbUrlsJsonPath = path_1.default.resolve(reportPath, constants_1.DATABASE_URLS_JSON_NAME);
    const mergedDbPath = path_1.default.resolve(reportPath, constants_1.LOCAL_DATABASE_NAME);
    if (!await fs_extra_1.default.pathExists(dbUrlsJsonPath)) {
        return;
    }
    const { dbUrls = [] } = await fs_extra_1.default.readJson(dbUrlsJsonPath);
    const extraDbPaths = dbUrls
        .filter(u => u !== constants_1.LOCAL_DATABASE_NAME)
        .map(u => path_1.default.resolve(reportPath, u));
    if (!extraDbPaths.length) {
        return;
    }
    common_utils_1.logger.warn(chalk_1.default.yellow(`Merge databases to ${constants_1.LOCAL_DATABASE_NAME}`));
    const mergedDatabase = await (0, server_1.makeSqlDatabaseFromFile)(mergedDbPath);
    const dbPaths = await Promise.all(extraDbPaths.map(p => (0, server_1.makeSqlDatabaseFromFile)(p).then(db => db.filename)));
    (0, server_1.mergeTables)({
        db: mergedDatabase,
        dbPaths,
        getExistingTables: (statement) => {
            const tables = [];
            while (statement.step()) {
                const row = statement.get();
                if (Array.isArray(row) && row.length > 0) {
                    tables.push(row[0]);
                }
            }
            return tables;
        }
    });
    const data = mergedDatabase.export();
    await fs_extra_1.default.writeFile(mergedDbPath, data);
    mergedDatabase.close();
    await Promise.all(extraDbPaths.map(p => fs_extra_1.default.remove(p)));
};
exports.mergeDatabasesForReuse = mergeDatabasesForReuse;
const prepareLocalDatabase = async (reportPath) => {
    debug('prepareLocalDatabase', reportPath);
    const dbPath = path_1.default.resolve(reportPath, constants_1.LOCAL_DATABASE_NAME);
    if (!fs_extra_1.default.existsSync(dbPath)) {
        return;
    }
    const db = await (0, server_1.makeSqlDatabaseFromFile)(dbPath);
    try {
        const version = (0, migrations_1.getDatabaseVersion)(db);
        debug('determined db version', version);
        if (version !== null && version < constants_1.DB_CURRENT_VERSION) {
            await (0, migrations_1.migrateDatabase)(db, version);
            await fs_extra_1.default.writeFile(dbPath, db.export());
        }
        else if (version === null) {
            const backupPath = await (0, migrations_1.backupAndReset)(reportPath);
            console.warn(`SQLite db at ${dbPath} is of unknown unsupported version.\nBacked up to ${backupPath} and starting from scratch.`);
        }
        else if (version > constants_1.DB_CURRENT_VERSION) {
            const backupPath = await (0, migrations_1.backupAndReset)(reportPath);
            console.warn(`SQLite db at ${dbPath} is of unsupported version. ` +
                'This probably happened because the report was generated with a newer version of html-reporter than you are trying to use now. ' +
                'Please update html-reporter to the latest version to open this report.\n' +
                `Backed up to ${backupPath} and starting from scratch.`);
        }
    }
    finally {
        db.close();
    }
};
exports.prepareLocalDatabase = prepareLocalDatabase;
const filterByEqualDiffSizes = (imagesInfo, refDiffClusters) => {
    if (!refDiffClusters || lodash_1.default.isEmpty(refDiffClusters)) {
        return [];
    }
    const refDiffSizes = refDiffClusters.map(getDiffClusterSizes);
    return lodash_1.default.filter(imagesInfo, (imageInfo) => {
        const imageInfoFail = imageInfo;
        const imageDiffSizes = imageInfoFail.diffClusters?.map(getDiffClusterSizes) ?? [];
        const equal = compareDiffSizes(imageDiffSizes, refDiffSizes);
        if (!equal) {
            return false;
        }
        if (!lodash_1.default.isEqual(imageDiffSizes, refDiffSizes)) {
            imageInfoFail.diffClusters = reorderClustersByEqualSize(imageInfoFail.diffClusters ?? [], imageDiffSizes, refDiffSizes);
        }
        return true;
    });
};
exports.filterByEqualDiffSizes = filterByEqualDiffSizes;
function getDiffClusterSizes(diffCluster) {
    return {
        width: diffCluster.right - diffCluster.left + 1,
        height: diffCluster.bottom - diffCluster.top + 1
    };
}
function compareDiffSizes(diffSizes1, diffSizes2) {
    if (diffSizes1.length !== diffSizes2.length) {
        return false;
    }
    return diffSizes1.every((diffSize) => {
        const foundIndex = lodash_1.default.findIndex(diffSizes2, diffSize);
        if (foundIndex < 0) {
            return false;
        }
        diffSizes2 = diffSizes2.filter((_v, ind) => ind !== foundIndex);
        return true;
    });
}
function reorderClustersByEqualSize(diffClusters1, diffSizes1, diffSizes2) {
    return diffClusters1.reduce((acc, cluster, i) => {
        if (diffSizes1[i] !== diffSizes2[i]) {
            const foundIndex = lodash_1.default.findIndex(diffSizes2, diffSizes1[i]);
            diffSizes2 = diffSizes2.filter((_v, ind) => ind !== foundIndex);
            acc[foundIndex] = cluster;
        }
        else {
            acc[i] = cluster;
        }
        return acc;
    }, []);
}
//# sourceMappingURL=utils.js.map