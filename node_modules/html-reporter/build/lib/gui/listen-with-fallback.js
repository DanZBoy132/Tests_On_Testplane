"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listenWithFallback = void 0;
const constants_1 = require("./constants");
const MAX_PORT_NUMBER = 65535;
const DEFAULT_PORT = 3000;
const listenOnPort = (server, portToTry, hostname) => {
    return new Promise((resolve, reject) => {
        // eslint-disable-next-line prefer-const
        let httpServer;
        const handleError = (error) => {
            httpServer.removeListener('error', handleError);
            reject(error);
        };
        const onListen = () => {
            resolve();
        };
        httpServer = hostname
            ? server.listen(portToTry, hostname, onListen)
            : server.listen(portToTry, onListen);
        httpServer.keepAliveTimeout = constants_1.KEEP_ALIVE_TIMEOUT;
        httpServer.headersTimeout = constants_1.HEADERS_TIMEOUT;
        httpServer.once('error', handleError);
    });
};
const listenWithFallback = async ({ server, hostname, requestedPort }) => {
    const hostnameForUrl = hostname ?? 'localhost';
    const startPort = requestedPort ?? DEFAULT_PORT;
    let currentPort = startPort;
    let isSuccess = false;
    while (currentPort <= MAX_PORT_NUMBER) {
        try {
            await listenOnPort(server, currentPort, hostname);
            isSuccess = true;
            break;
        }
        catch (error) {
            const err = error;
            if (err.code !== 'EADDRINUSE') {
                throw err;
            }
            if (currentPort >= MAX_PORT_NUMBER) {
                throw new Error(`Unable to find an available port to start GUI server: ${err.message}`);
            }
            currentPort += 1;
        }
    }
    if (!isSuccess) {
        throw new Error(`Unable to find an available port (tried all variants between ${startPort} and ${MAX_PORT_NUMBER})`);
    }
    return {
        actualPort: currentPort,
        hostnameForUrl
    };
};
exports.listenWithFallback = listenWithFallback;
//# sourceMappingURL=listen-with-fallback.js.map