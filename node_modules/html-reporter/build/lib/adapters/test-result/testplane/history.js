"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHistory = exports.collapseRepeatingGroups = exports.MIN_REPEATS = exports.getItemAverageTime = exports.getTotalTime = exports.wrapSkipComment = exports.getSkipComment = void 0;
const types_1 = require("../../../types");
const getSkipComment = (suite) => (suite.skipReason || suite.parent && (0, exports.getSkipComment)(suite.parent));
exports.getSkipComment = getSkipComment;
const wrapSkipComment = (skipComment) => (skipComment ?? 'Unknown reason');
exports.wrapSkipComment = wrapSkipComment;
const testItemsAreTheSame = (a, b) => (a &&
    (!a[types_1.TestStepKey.Children] || !b[types_1.TestStepKey.Children]) &&
    (!a[types_1.TestStepKey.IsFailed] || !b[types_1.TestStepKey.IsFailed]) &&
    a[types_1.TestStepKey.Name] === b[types_1.TestStepKey.Name] &&
    a[types_1.TestStepKey.Args].join() === b[types_1.TestStepKey.Args].join());
const arraysEqual = (a, b, checkFunc) => {
    if (a.length !== b.length) {
        return false;
    }
    return a.every((val, idx) => checkFunc(val, b[idx]));
};
const getTotalTime = (items, start, size) => {
    let total = 0;
    for (let i = start; i < (start + size); i++) {
        if (items[i] && items[i][types_1.TestStepKey.Duration]) {
            total += items[i][types_1.TestStepKey.Duration];
        }
    }
    return total;
};
exports.getTotalTime = getTotalTime;
const getItemAverageTime = (items, start, repeat, index, groupLen) => {
    let total = 0;
    for (let i = 0; i < (repeat - 1); i++) {
        total += items[start + (i * groupLen) + index][types_1.TestStepKey.Duration];
    }
    return parseFloat((total / (repeat - 1)).toFixed(2));
};
exports.getItemAverageTime = getItemAverageTime;
exports.MIN_REPEATS = 3; // Min count of repeats elements of group elements for squash
const collapseRepeatingGroups = (arr, minRepeats = exports.MIN_REPEATS) => {
    const result = [];
    let i = 0;
    while (i < arr.length) {
        let foundGroup = false;
        // max len of group can't be more that totalLen / minRepeats
        for (let groupLen = 1; groupLen <= Math.floor((arr.length - i) / minRepeats); groupLen++) {
            const group = arr.slice(i, i + groupLen);
            let allGroupsMatch = true;
            // check that group is repeated required count of times
            for (let repeat = 1; repeat < minRepeats; repeat++) {
                const nextGroupStart = i + repeat * groupLen;
                const nextGroupEnd = nextGroupStart + groupLen;
                if (nextGroupEnd > arr.length) {
                    allGroupsMatch = false;
                    break;
                }
                const nextGroup = arr.slice(nextGroupStart, nextGroupEnd);
                if (!arraysEqual(group, nextGroup, testItemsAreTheSame)) {
                    allGroupsMatch = false;
                    break;
                }
            }
            if (allGroupsMatch) {
                foundGroup = true;
                let repeatCount = minRepeats;
                // finding another repeats of group
                while (i + groupLen * repeatCount <= arr.length &&
                    arraysEqual(group, arr.slice(i + groupLen * repeatCount, i + groupLen * (repeatCount + 1)), testItemsAreTheSame)) {
                    repeatCount++;
                }
                const groupsTotalLen = groupLen * repeatCount;
                if (groupLen === 1) {
                    result.push({
                        ...group[0],
                        [types_1.TestStepKey.Duration]: (0, exports.getTotalTime)(arr, i, groupsTotalLen),
                        [types_1.TestStepKey.Repeat]: groupsTotalLen
                    });
                }
                else {
                    result.push({
                        [types_1.TestStepKey.Name]: 'Repeated group',
                        [types_1.TestStepKey.Args]: [`${group.length} items`],
                        [types_1.TestStepKey.Duration]: (0, exports.getTotalTime)(arr, i, groupsTotalLen),
                        [types_1.TestStepKey.TimeStart]: group[0][types_1.TestStepKey.TimeStart],
                        [types_1.TestStepKey.IsFailed]: false,
                        [types_1.TestStepKey.IsGroup]: true,
                        [types_1.TestStepKey.Children]: group.map((item, index) => ({
                            ...item,
                            [types_1.TestStepKey.Repeat]: -1,
                            [types_1.TestStepKey.Duration]: (0, exports.getItemAverageTime)(arr, i, repeatCount, index, groupLen)
                        })),
                        [types_1.TestStepKey.Repeat]: repeatCount
                    });
                }
                i += groupsTotalLen;
                break;
            }
        }
        if (!foundGroup) {
            result.push(arr[i]);
            i++;
        }
    }
    return result;
};
exports.collapseRepeatingGroups = collapseRepeatingGroups;
const getHistory = (history, saveHistoryMode = 'all') => ((0, exports.collapseRepeatingGroups)(history?.map((step) => {
    const result = {
        [types_1.TestStepKey.Name]: step[types_1.TestStepKey.Name],
        [types_1.TestStepKey.Args]: step[types_1.TestStepKey.Args],
        [types_1.TestStepKey.Duration]: step[types_1.TestStepKey.Duration],
        [types_1.TestStepKey.TimeStart]: step[types_1.TestStepKey.TimeStart],
        [types_1.TestStepKey.IsFailed]: step[types_1.TestStepKey.IsFailed],
        [types_1.TestStepKey.IsGroup]: step[types_1.TestStepKey.IsGroup]
    };
    if (step[types_1.TestStepKey.Children] && ((step[types_1.TestStepKey.IsGroup] && saveHistoryMode === 'all') ||
        (step[types_1.TestStepKey.IsFailed] && (saveHistoryMode === 'all' || saveHistoryMode === 'onlyFailed')))) {
        result[types_1.TestStepKey.Children] = (0, exports.getHistory)(step[types_1.TestStepKey.Children], saveHistoryMode);
    }
    return result;
}) ?? [], exports.MIN_REPEATS));
exports.getHistory = getHistory;
//# sourceMappingURL=history.js.map