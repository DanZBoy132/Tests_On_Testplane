"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTestsTreeBuilder = void 0;
const common_utils_1 = require("../common-utils");
const constants_1 = require("../constants");
const tree_1 = require("../adapters/test-result/transformers/tree");
class BaseTestsTreeBuilder {
    static create(options = {}) {
        return new this(options);
    }
    constructor(options = {}) {
        this._transformer = new tree_1.TreeTestResultTransformer(options);
        this._tree = {
            suites: { byId: {}, byHash: {}, allIds: [], allRootIds: [] },
            browsers: { byId: {}, allIds: [] },
            results: { byId: {}, allIds: [] },
            images: { byId: {}, allIds: [] }
        };
    }
    get tree() {
        return this._tree;
    }
    sortTree() {
        const sortChildSuites = (suiteId) => {
            const childSuite = this._tree.suites.byId[suiteId];
            if (childSuite.suiteIds) {
                childSuite.suiteIds.sort().forEach(sortChildSuites);
            }
            if (childSuite.browserIds) {
                childSuite.browserIds.sort();
            }
        };
        this._tree.suites.allRootIds.sort().forEach(sortChildSuites);
    }
    addTestResult(formattedResult) {
        const { testPath, browserId: browserName, attempt, imagesInfo = [] } = formattedResult;
        const { browserVersion = constants_1.BrowserVersions.UNKNOWN } = formattedResult.meta;
        const suiteId = this._buildId(testPath);
        const browserId = this._buildId(suiteId, browserName);
        const testResultId = this._buildId(browserId, attempt.toString());
        const imageIds = imagesInfo
            .map((image, i) => this._buildId(testResultId, image.stateName || `${image.status}_${i}`));
        this._addSuites(testPath, browserId);
        this._addBrowser({ id: browserId, parentId: suiteId, name: browserName, version: browserVersion }, testResultId, attempt);
        this._addResult({ id: testResultId, parentId: browserId, result: formattedResult }, imageIds);
        this._addImages(imageIds, { imagesInfo, parentId: testResultId });
        this._setStatusForBranch(testPath);
    }
    _buildId(parentId = [], name = []) {
        return [].concat(parentId, name).join(constants_1.DEFAULT_TITLE_DELIMITER);
    }
    _addSuites(testPath, browserId) {
        testPath.reduce((suites, name, ind, arr) => {
            const isRoot = ind === 0;
            const suitePath = isRoot ? [name] : arr.slice(0, ind + 1);
            const id = this._buildId(suitePath);
            if (!suites.byId[id]) {
                const parentId = isRoot ? null : this._buildId(suitePath.slice(0, -1));
                const hash = (0, common_utils_1.getShortMD5)(id);
                const suite = { id, hash, parentId, name, suitePath, root: isRoot };
                this._addSuite(suite);
            }
            const treeSuite = this._tree.suites.byId[id];
            if (ind !== arr.length - 1) {
                const childSuiteId = this._buildId(id, arr[ind + 1]);
                if (treeSuite.suiteIds) {
                    // We add suites from parent to child
                    // So if there is no child yet, its not present in "treeSuite.suiteIds"
                    // But it will in next iteration of this "reduce" cycle, which is synchronous
                    if (!this._tree.suites.byId[childSuiteId] || !treeSuite.suiteIds.includes(childSuiteId)) {
                        treeSuite.suiteIds.push(childSuiteId);
                    }
                }
                else {
                    treeSuite.suiteIds = [childSuiteId];
                }
            }
            else {
                if (treeSuite.browserIds) {
                    if (!this._tree.browsers.byId[browserId] || !treeSuite.browserIds.includes(browserId)) {
                        treeSuite.browserIds.push(browserId);
                    }
                }
                else {
                    treeSuite.browserIds = [browserId];
                }
            }
            return suites;
        }, this._tree.suites);
    }
    _addSuite(suite) {
        const { suites } = this._tree;
        suites.byId[suite.id] = suite;
        suites.byHash[suite.hash] = suite;
        suites.allIds.push(suite.id);
        if (suite.root) {
            suites.allRootIds.push(suite.id);
        }
    }
    _addBrowser({ id, parentId, name, version }, testResultId, attempt) {
        const { browsers } = this._tree;
        if (!browsers.byId[id]) {
            browsers.byId[id] = { id, parentId, name, resultIds: [], version };
            browsers.allIds.push(id);
        }
        this._addResultIdToBrowser(id, testResultId, attempt);
    }
    _addResultIdToBrowser(browserId, testResultId, attempt) {
        this._tree.browsers.byId[browserId].resultIds[attempt] = testResultId;
    }
    _addResult({ id, parentId, result }, imageIds) {
        const treeResult = this._transformer.transform(result);
        if (!this._tree.results.byId[id]) {
            this._tree.results.allIds.push(id);
        }
        this._tree.results.byId[id] = { attempt: 0, id, parentId, ...treeResult, imageIds };
    }
    _addImages(imageIds, { imagesInfo, parentId }) {
        imageIds.forEach((id, ind) => {
            this._tree.images.byId[id] = { ...imagesInfo[ind], id, parentId };
            this._tree.images.allIds.push(id);
        });
    }
    _setStatusForBranch(testPath = []) {
        const suiteId = this._buildId(testPath);
        if (!suiteId) {
            return;
        }
        const suite = this._tree.suites.byId[suiteId];
        const uniqueChildStatuses = [];
        for (const browserId of suite.browserIds || []) {
            if (!browserId) {
                continue;
            }
            const browserResultIds = this._tree.browsers.byId[browserId].resultIds;
            const lastResultId = browserResultIds[browserResultIds.length - 1];
            const lastResultStatus = this._tree.results.byId[lastResultId].status;
            if (lastResultStatus && !uniqueChildStatuses.includes(lastResultStatus)) {
                uniqueChildStatuses.push(lastResultStatus);
            }
        }
        for (const childSuiteId of suite.suiteIds || []) {
            if (!childSuiteId) {
                continue;
            }
            const childSuiteStatus = this._tree.suites.byId[childSuiteId].status;
            if (childSuiteStatus && !uniqueChildStatuses.includes(childSuiteStatus)) {
                uniqueChildStatuses.push(childSuiteStatus);
            }
        }
        // Updating parent suites status, implying "finalStatus(A, A, A, B) === finalStatus(A, B)"
        suite.status = (0, common_utils_1.determineFinalStatus)(uniqueChildStatuses) || void 0;
        if (!suite.status) {
            return;
        }
        for (let i = 1; i < testPath.length; i++) {
            const parentTestPath = testPath.slice(0, -i);
            const parentSuiteId = this._buildId(parentTestPath);
            const parentSuite = this._tree.suites.byId[parentSuiteId];
            if (parentSuite.status === suite.status) {
                return;
            }
            if (!parentSuite.status) {
                parentSuite.status = suite.status;
                continue;
            }
            else {
                this._setStatusForBranch(parentTestPath);
                break;
            }
        }
    }
}
exports.BaseTestsTreeBuilder = BaseTestsTreeBuilder;
//# sourceMappingURL=base.js.map