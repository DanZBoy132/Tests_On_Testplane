/// <reference types="gemini-testing__sql.js" />
import { CoordBounds } from 'looks-same';
import { Page, BrowserFeature, DiffModeId, Feature, TestStatus, ViewMode, TwoUpFitMode } from "../../../constants";
import { Attachment, BrowserItem, ImageFile, RefImageFile, StoreReporterConfig, TestError, TestStepCompressed } from "../../../types";
import { HtmlReporterValues } from "../../../plugin-api";
import { Point } from "./index";
import { AcceptableImage } from "../../modules/static-image-accepter";
import { CheckStatus } from "../../../constants/checked-statuses";
import { EntityType } from "../features/suites/components/SuitesPage/types";
import { DbDetails } from "../../../db-utils/common";
import { Stats, PerBrowserStats } from "../../../tests-tree-builder/static";
import type { Database } from '@gemini-testing/sql.js';
export interface GroupEntity {
    id: string;
    /** @note For cosmetic purposes, grouping key. For example: "url". */
    key: string;
    /** @note For cosmetic purposes, group value. For example: "https://example.com" */
    label: string;
    resultIds: string[];
    browserIds: string[];
    type: EntityType.Group;
}
export interface SuiteEntityNode {
    id: string;
    hash: string;
    name: string;
    parentId: string | null;
    status: TestStatus;
    suiteIds: string[];
    suitePath: string[];
}
export interface SuiteEntityLeaf {
    id: string;
    hash: string;
    name: string;
    parentId: string | null;
    status: TestStatus;
    browserIds: string[];
    suitePath: string[];
}
export type SuiteEntity = SuiteEntityNode | SuiteEntityLeaf;
export declare const hasBrowsers: (suite: SuiteEntity) => suite is SuiteEntityLeaf;
export declare const hasSuites: (suite: SuiteEntity) => suite is SuiteEntityNode;
export interface BrowserEntity {
    id: string;
    name: string;
    resultIds: string[];
    imageIds: string[];
    parentId: string;
}
export declare const isSuiteEntity: (entity: SuiteEntity | BrowserEntity | GroupEntity) => entity is SuiteEntity;
export declare const isBrowserEntity: (entity: SuiteEntity | BrowserEntity) => entity is BrowserEntity;
export declare const isGroupEntity: (entity: SuiteEntity | BrowserEntity | GroupEntity) => entity is GroupEntity;
export interface ResultEntityCommon {
    id: string;
    parentId: string;
    attempt: number;
    imageIds: string[];
    status: TestStatus;
    timestamp: number;
    metaInfo: Record<string, string>;
    suiteUrl?: string;
    history?: TestStepCompressed[];
    error?: TestError;
    suitePath: string[];
    /** @note Browser Name/ID, e.g. `chrome-desktop` */
    name: string;
    skipReason?: string;
    duration?: number;
    attachments?: Attachment[];
}
export interface ResultEntityError extends ResultEntityCommon {
    error: TestError;
    status: TestStatus.ERROR | TestStatus.FAIL;
}
export type ResultEntity = ResultEntityCommon | ResultEntityError;
export declare const isResultEntityError: (result: ResultEntity) => result is ResultEntityError;
interface ImageEntityCommon {
    id: string;
    /** @note Corresponding ResultEntity id */
    parentId: string;
}
export interface ImageEntitySuccess extends ImageEntityCommon {
    status: TestStatus.SUCCESS;
    stateName: string;
    expectedImg: ImageFile;
    refImg: RefImageFile;
}
export interface ImageEntityUpdated extends ImageEntityCommon {
    status: TestStatus.UPDATED;
    stateName: string;
    expectedImg: ImageFile;
    refImg: RefImageFile;
}
export interface ImageEntityStaged extends ImageEntityCommon {
    status: TestStatus.STAGED;
    stateName: string;
    actualImg: ImageFile;
    refImg: RefImageFile;
}
export interface ImageEntityCommitted extends ImageEntityCommon {
    status: TestStatus.COMMITED;
    stateName: string;
    actualImg: ImageFile;
    refImg: RefImageFile;
}
export interface ImageEntityError extends ImageEntityCommon {
    status: TestStatus.ERROR;
    stateName?: string;
    actualImg: ImageFile;
    error?: TestError;
    refImg?: RefImageFile;
}
export interface ImageEntityFail extends ImageEntityCommon {
    status: TestStatus.FAIL;
    stateName: string;
    diffClusters: CoordBounds[];
    diffImg: ImageFile;
    actualImg: ImageFile;
    expectedImg: ImageFile;
    refImg: RefImageFile;
}
export type ImageEntity = ImageEntityError | ImageEntityFail | ImageEntitySuccess | ImageEntityUpdated | ImageEntityStaged | ImageEntityCommitted;
export declare const isImageEntityFail: (image: ImageEntity) => image is ImageEntityFail;
export interface SuiteState {
    shouldBeOpened: boolean;
    shouldBeShown: boolean;
    checkStatus: CheckStatus;
}
export interface BrowserState {
    shouldBeShown: boolean;
    retryIndex: number;
    lastMatchedRetryIndex?: number | null;
    isHiddenBecauseOfStatus?: boolean;
    checkStatus: CheckStatus;
    fuzzyMatchScore?: number;
}
export interface ResultState {
    matchedSelectedGroup: boolean;
}
export interface TreeEntity {
    browsers: {
        allIds: string[];
        byId: Record<string, BrowserEntity>;
        stateById: Record<string, BrowserState>;
    };
    images: {
        byId: Record<string, ImageEntity>;
    };
    results: {
        byId: Record<string, ResultEntity>;
        stateById: Record<string, ResultState>;
    };
    suites: {
        allRootIds: string[];
        byId: Record<string, SuiteEntity>;
        byHash: Record<string, SuiteEntity>;
        stateById: Record<string, SuiteState>;
    };
    groups: {
        byId: Record<string, GroupEntity>;
        allRootIds: string[];
    };
}
export interface GroupBySection {
    id: string;
    label: string;
}
export declare enum GroupByType {
    Meta = "meta",
    Error = "error"
}
export interface GroupByMetaExpression {
    id: string;
    type: GroupByType.Meta;
    sectionId?: string;
    key: string;
}
export interface GroupByErrorExpression {
    id: string;
    type: GroupByType.Error;
    sectionId?: string;
}
export type GroupByExpression = GroupByMetaExpression | GroupByErrorExpression;
export declare enum SortType {
    ByName = 0,
    ByFailedRuns = 1,
    ByTestsCount = 2,
    ByStartTime = 3,
    ByDuration = 4,
    ByRelevance = 5
}
export declare enum SortDirection {
    Asc = "asc",
    Desc = "desc"
}
export interface SortByExpression {
    id: string;
    type: SortType;
    label: string;
}
export declare enum TreeViewMode {
    Tree = "tree",
    List = "list"
}
export interface SnapshotsPlayerHighlightState {
    isActive: boolean;
    highlightStartTime: number;
    highlightEndTime: number;
    goToTime: number;
}
export interface State {
    app: {
        isNewUi: boolean;
        isInitialized: boolean;
        availableFeatures: Feature[];
        isSearchLoading?: boolean;
        [Page.suitesPage]: {
            currentTreeNodeId: string | null;
            currentBrowserId: string | null;
            currentGroupId: string | null;
            currentStepId: string | null;
            currentHighlightedStepId: string | null;
            nameFilter: string;
            useRegexFilter: boolean;
            useMatchCaseFilter: boolean;
            viewMode: ViewMode;
            filteredBrowsers: BrowserItem[];
        };
        [Page.visualChecksPage]: {
            currentBrowserId: string | null;
            stateName: string | null;
            nameFilter: string;
            useRegexFilter: boolean;
            useMatchCaseFilter: boolean;
            viewMode: ViewMode;
            filteredBrowsers: BrowserItem[];
            diffMode: DiffModeId;
        };
        loading: {
            /** @note Determines whether the loading bar is visible */
            isVisible: boolean;
            /** @note Determines visibility of bouncing dots at the end of the task title */
            isInProgress: boolean;
            taskTitle: string;
            /** @note Maps ID of a resource to its loading progress. E.g. dbUrl: 88. Progress is measured from 0 to 1. */
            progress: Record<string, number>;
        };
        staticImageAccepterModal: {
            commitMessage: string;
        };
        groupTestsData: {
            availableSections: GroupBySection[];
            availableExpressions: GroupByExpression[];
            currentExpressionIds: string[];
        };
        sortTestsData: {
            availableExpressions: SortByExpression[];
            currentExpressionIds: string[];
            currentDirection: SortDirection;
            previousExpressionIds: string[];
            previousDirection: SortDirection;
        };
        guiServerConnection: {
            isConnected: boolean;
        };
        snapshotsPlayer: SnapshotsPlayerHighlightState;
    };
    ui: {
        [Page.suitesPage]: {
            treeViewMode: TreeViewMode;
            retryIndexByTreeNodeId: Record<string, number | null>;
            expandedTreeNodesById: Record<string, boolean>;
            expandedSectionsById: Record<string, boolean>;
            expandedStepsByResultId: Record<string, Record<string, boolean>>;
            sectionSizes: number[];
            backupSectionSizes: number[];
            isSnapshotsPlayerVisible: boolean;
        };
        [Page.visualChecksPage]: {
            sectionSizes: number[];
            backupSectionSizes: number[];
            is2UpDiffVisible: boolean;
            twoUpFitMode: TwoUpFitMode;
        };
        staticImageAccepterToolbar: {
            offset: Point;
        };
    };
    browsers: BrowserItem[];
    browserFeatures: Record<string, BrowserFeature[]>;
    tree: TreeEntity;
    view: {
        diffMode: DiffModeId;
        /** @deprecated Use tree.groups instead. */
        keyToGroupTestsBy: string;
        baseHost: string;
    };
    running: boolean;
    processing: boolean;
    gui: boolean;
    apiValues: HtmlReporterValues;
    config: StoreReporterConfig;
    staticImageAccepter: {
        enabled: boolean;
        acceptableImages: Record<string, AcceptableImage>;
        accepterDelayedImages: {
            imageId: string;
            stateName: string;
            stateNameImageId: string;
        }[];
        imagesToCommitCount: number;
    };
    timestamp: number;
    fetchDbDetails: DbDetails[];
    stats: {
        all: Stats | Record<string, never>;
        perBrowser: PerBrowserStats | undefined;
    } | null;
    db?: Database;
    plugins: Record<string, unknown>;
}
declare module 'react-redux' {
    interface DefaultRootState extends State {
    }
}
export {};
