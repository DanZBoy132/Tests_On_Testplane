import type { EventEmitter } from 'node:events';
import type { Options } from '@testplane/wdio-types';
import type { WebDriverResponse } from './request/types.js';
import type { Client, JSONWPCommandError, SessionFlags, RemoteConfig } from './types.js';
/**
 * start browser session with WebDriver protocol
 */
export declare function startWebDriverSession(params: RemoteConfig): Promise<{
    sessionId: string;
    capabilities: WebdriverIO.Capabilities;
}>;
/**
 * Validates the given WebdriverIO capabilities.
 *
 * @param {WebdriverIO.Capabilities} capabilities - The capabilities to validate.
 * @throws {Error} If the capabilities contain incognito mode.
 */
export declare function validateCapabilities(capabilities: WebdriverIO.Capabilities): void;
/**
 * check if WebDriver requests was successful
 * @param  {number}  statusCode status code of request
 * @param  {Object}  body       body payload of response
 * @return {Boolean}            true if request was successful
 */
export declare function isSuccessfulResponse(statusCode?: number, body?: unknown): boolean;
/**
 * creates the base prototype for the webdriver monad
 */
export declare function getPrototype({ isW3C, isChromium, isFirefox, isMobile, isSauce, isSeleniumStandalone }: Partial<SessionFlags>): Record<string, PropertyDescriptor>;
/**
 * helper method to determine the error from webdriver response
 * @param  {Object} body body object
 * @return {Object} error
 */
export declare function getErrorFromResponseBody(body: unknown, requestOptions: unknown): Error;
export declare class CustomRequestError extends Error {
    constructor(body: WebDriverResponse, requestOptions: any);
}
/**
 * return all supported flags and return them in a format so we can attach them
 * to the instance protocol
 * @param  {Object} options   driver instance or option object containing these flags
 * @return {Object}           prototype object
 */
export declare function getEnvironmentVars({ isW3C, isMobile, isIOS, isAndroid, isFirefox, isSauce, isSeleniumStandalone, isChromium }: Partial<SessionFlags>): PropertyDescriptorMap;
/**
 * Decorate the client's options object with host updates based on the presence of
 * directConnect capabilities in the new session response. Note that this
 * mutates the object.
 * @param  {Client} params post-new-session client
 */
export declare function setupDirectConnect(client: Client): void;
/**
 * get human-readable message from response error
 * @param {Error} err response error
 * @param params
 */
export declare const getSessionError: (err: JSONWPCommandError, params?: Partial<Options.WebDriver>) => string;
/**
 * return timeout error with information about the executing command on which the test hangs
 */
export declare const getTimeoutError: (error: Error, requestOptions: Options.RequestLibOptions) => Error;
/**
 * Enhance the monad with WebDriver Bidi primitives if a connection can be established successfully
 * @param socketUrl url to bidi interface
 * @param strictSSL
 * @param userHeaders
 * @returns prototype with interface for bidi primitives
 */
export declare function initiateBidi(socketUrl: string, strictSSL?: boolean, userHeaders?: Record<string, string>): PropertyDescriptorMap;
export declare function parseBidiMessage(this: EventEmitter, data: Buffer): void;
