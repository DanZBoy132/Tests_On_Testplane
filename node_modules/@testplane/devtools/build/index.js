var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/index.ts
import os4 from "node:os";
import path6 from "node:path";
import UAParser from "ua-parser-js";
import { v4 as uuidv44 } from "uuid";
import logger4 from "@testplane/wdio-logger";
import { webdriverMonad, devtoolsEnvironmentDetector } from "@testplane/wdio-utils";
import { validateConfig } from "@testplane/wdio-config";

// src/devtoolsdriver.ts
import { v4 as uuidv43 } from "uuid";
import logger3 from "@testplane/wdio-logger";

// src/commands/index.ts
var commands_exports = {};
__export(commands_exports, {
  acceptAlert: () => acceptAlert,
  addCookie: () => addCookie,
  back: () => back,
  closeWindow: () => closeWindow,
  createWindow: () => createWindow2,
  deleteAllCookies: () => deleteAllCookies,
  deleteCookie: () => deleteCookie,
  deleteSession: () => deleteSession,
  dismissAlert: () => dismissAlert,
  elementClear: () => elementClear2,
  elementClick: () => elementClick,
  elementSendKeys: () => elementSendKeys,
  executeAsyncScript: () => executeAsyncScript,
  executeScript: () => executeScript,
  findElement: () => findElement2,
  findElementFromElement: () => findElementFromElement,
  findElementFromShadowRoot: () => findElementFromShadowRoot,
  findElements: () => findElements2,
  findElementsFromElement: () => findElementFromElements,
  findElementsFromShadowRoot: () => findElementsFromShadowRoot,
  forward: () => forward,
  getActiveElement: () => getActiveElement2,
  getAlertText: () => getAlertText,
  getAllCookies: () => getAllCookies,
  getElementAttribute: () => getElementAttribute2,
  getElementCSSValue: () => getElementCSSValue2,
  getElementComputedLabel: () => getElementComputedLabel,
  getElementComputedRole: () => getElementComputedRole,
  getElementProperty: () => getElementProperty,
  getElementRect: () => getElementRect2,
  getElementShadowRoot: () => getElementShadowRoot,
  getElementTagName: () => getElementTagName2,
  getElementText: () => getElementText2,
  getNamedCookie: () => getNamedCookie,
  getPageSource: () => getPageSource,
  getTimeouts: () => getTimeouts,
  getTitle: () => getTitle,
  getUrl: () => getUrl2,
  getWindowHandle: () => getWindowHandle,
  getWindowHandles: () => getWindowHandles,
  getWindowRect: () => getWindowRect,
  isElementEnabled: () => isElementEnabled,
  isElementSelected: () => isElementSelected,
  navigateTo: () => navigateTo,
  newSession: () => newSession,
  performActions: () => performActions,
  refresh: () => refresh,
  releaseActions: () => performActions2,
  sendAlertText: () => sendAlertText,
  setTimeouts: () => setTimeouts,
  setWindowRect: () => setWindowRect,
  status: () => status,
  switchToFrame: () => switchToFrame,
  switchToParentFrame: () => switchToParentFrame,
  switchToWindow: () => switchToWindow,
  takeElementScreenshot: () => takeElementScreenshot,
  takeScreenshot: () => takeScreenshot
});

// src/commands/acceptAlert.ts
async function acceptAlert() {
  if (!this.activeDialog) {
    throw new Error("no such alert");
  }
  await this.activeDialog.accept(this.activeDialog.defaultValue());
  delete this.activeDialog;
  return null;
}

// src/commands/addCookie.ts
async function addCookie({ cookie }) {
  const page = this.getPageHandle();
  const cookieProps = Object.keys(cookie);
  if (!cookieProps.includes("name") || !cookieProps.includes("value")) {
    throw new Error(
      'Provided cookie object is missing either "name" or "value" property'
    );
  }
  if (typeof cookie.value !== "string") {
    cookie.value = cookie.value.toString();
  }
  await page.setCookie(cookie);
  return null;
}

// src/commands/back.ts
async function back() {
  delete this.currentFrame;
  const page = this.getPageHandle();
  await page.goBack();
  return null;
}

// src/commands/closeWindow.ts
import { v4 as uuidv4 } from "uuid";

// src/utils.ts
import fs from "node:fs/promises";
import util from "node:util";
import which from "which";
import logger from "@testplane/wdio-logger";
import { resolve } from "import-meta-resolve";
import { commandCallStructure, isValidParameter, getArgumentType } from "@testplane/wdio-utils";
import { canAccess } from "@testplane/wdio-utils/node";
import { WebDriverProtocol } from "@testplane/wdio-protocols";
import { launch as launchChromeBrowser } from "chrome-launcher";

// src/scripts/cleanUpSerializationSelector.ts
function cleanUp(elem, dataProperty2) {
  const elems = Array.isArray(elem) ? elem : [elem];
  for (const el of elems) {
    el.removeAttribute(dataProperty2);
  }
}

// src/constants.ts
var DEFAULT_WIDTH = 1200;
var DEFAULT_HEIGHT = 900;
var DEFAULT_X_POSITION = 0;
var DEFAULT_Y_POSITION = 0;
var ELEMENT_KEY = "element-6066-11e4-a52e-4f735466cecf";
var SHADOW_ELEMENT_KEY = "shadow-6066-11e4-a52e-4f735466cecf";
var DEFAULT_FLAGS = [
  // suppresses Save Password prompt window
  "--enable-automation",
  // do not block popups
  "--disable-popup-blocking",
  // Disable all chrome extensions entirely
  "--disable-extensions",
  // Disable various background network services, including extension updating,
  //   safe browsing service, upgrade detector, translate, UMA
  "--disable-background-networking",
  "--disable-background-timer-throttling",
  "--disable-backgrounding-occluded-windows",
  // Disable syncing to a Google account
  "--disable-sync",
  // Disable reporting to UMA, but allows for collection
  "--metrics-recording-only",
  // Disable installation of default apps on first run
  "--disable-default-apps",
  // Mute any audio
  "--mute-audio",
  // Skip first run wizards
  "--no-first-run",
  "--no-default-browser-check",
  // chromedriver flags
  "--disable-hang-monitor",
  "--disable-prompt-on-repost",
  "--disable-client-side-phishing-detection",
  "--password-store=basic",
  "--use-mock-keychain",
  "--disable-component-extensions-with-background-pages",
  "--disable-breakpad",
  "--disable-dev-shm-usage",
  "--disable-ipc-flooding-protection",
  "--disable-renderer-backgrounding",
  "--force-fieldtrials=*BackgroundTracing/default/",
  "--enable-features=NetworkService,NetworkServiceInProcess",
  /**
   * `site-per-process` affects `page.frames()`, see #4471
   * `TranslateUI` disables built-in Google Translate service
   */
  "--disable-features=site-per-process,TranslateUI,BlinkGenPropertyTrees"
];
var CHROME_NAMES = ["chrome", "googlechrome", "headlesschrome", "google-chrome", "chromium"];
var FIREFOX_NAMES = ["firefox", "ff", "mozilla", "mozillafirefox", "headless firefox", "headlessfirefox"];
var EDGE_NAMES = ["edge", "msedge", "microsoft-edge", "microsoftedge"];
var SUPPORTED_BROWSER = [...CHROME_NAMES, ...FIREFOX_NAMES, ...EDGE_NAMES];
var BROWSER_TYPE = {
  chrome: "chrome",
  firefox: "firefox",
  edge: "edge"
};
var DEFAULTS = {
  capabilities: {
    type: "object",
    required: true
  },
  /**
   * Level of logging verbosity
   */
  logLevel: {
    type: "string",
    default: "info",
    match: /(trace|debug|info|warn|error|silent)/
  },
  /**
   * directory for log files
   */
  outputDir: {
    type: "string"
  },
  /**
   * maxConnectionRetries in chrome-launcher
   */
  connectionRetryCount: {
    type: "number",
    default: 50
  }
};
var DEFAULT_IMPLICIT_TIMEOUT = 0;
var DEFAULT_PAGELOAD_TIMEOUT = 5 * 60 * 1e3;
var DEFAULT_SCRIPT_TIMEOUT = 30 * 1e3;
var SUPPORTED_SELECTOR_STRATEGIES = ["css selector", "tag name", "xpath", "link text", "partial link text", "shadow"];
var SERIALIZE_PROPERTY = "data-devtoolsdriver-fetchedElement";
var SERIALIZE_FLAG = "__executeElement";
var ERROR_MESSAGES = {
  staleElement: {
    name: "stale element reference",
    message: "stale element reference: The element reference is stale; either the element is no longer attached to the DOM, it is not in the current frame context, or the document has been refreshed"
  }
};
var VENDOR_PREFIX = {
  chrome: "goog:chromeOptions",
  "chrome headless": "goog:chromeOptions",
  firefox: "moz:firefoxOptions",
  edge: "ms:edgeOptions"
};
var UNICODE_CHARACTERS = {
  "Cancel": "\uE001",
  "Help": "\uE002",
  "Backspace": "\uE003",
  "Tab": "\uE004",
  "Clear": "\uE005",
  "Enter": "\uE006",
  "NumpadEnter": "\uE007",
  "ShiftLeft": "\uE008",
  "ControlLeft": "\uE009",
  "ControlRight": "\uE051",
  "AltLeft": "\uE00A",
  "Pause": "\uE00B",
  "Escape": "\uE00C",
  "Space": "\uE00D",
  "PageUp": "\uE00E",
  "PageDown": "\uE00F",
  "End": "\uE010",
  "Home": "\uE011",
  "ArrowLeft": "\uE012",
  "ArrowUp": "\uE013",
  "ArrowRight": "\uE014",
  "ArrowDown": "\uE015",
  "Insert": "\uE016",
  "Delete": "\uE017",
  "Semicolon": "\uE018",
  "=": "\uE019",
  "Numpad0": "\uE01A",
  "Numpad1": "\uE01B",
  "Numpad2": "\uE01C",
  "Numpad3": "\uE01D",
  "Numpad4": "\uE01E",
  "Numpad5": "\uE01F",
  "Numpad6": "\uE020",
  "Numpad7": "\uE021",
  "Numpad8": "\uE022",
  "Numpad9": "\uE023",
  "NumpadMultiply": "\uE024",
  "NumpadAdd": "\uE025",
  "Separator": "\uE026",
  "NumpadSubtract": "\uE027",
  "NumpadDecimal": "\uE028",
  "NumpadDivide": "\uE029",
  "F1": "\uE031",
  "F2": "\uE032",
  "F3": "\uE033",
  "F4": "\uE034",
  "F5": "\uE035",
  "F6": "\uE036",
  "F7": "\uE037",
  "F8": "\uE038",
  "F9": "\uE039",
  "F10": "\uE03A",
  "F11": "\uE03B",
  "F12": "\uE03C",
  "MetaLeft": "\uE03D"
};

// src/utils.ts
var log = logger("devtools");
var validate = function(command, parameters, variables, ref, args2) {
  const commandParams = [...variables.map((v) => Object.assign(v, {
    /**
     * url variables are:
     */
    required: true,
    // always required as they are part of the endpoint
    type: "string"
    // have to be always type of string
  })), ...parameters];
  const commandUsage = `${command}(${commandParams.map((p) => p.name).join(", ")})`;
  const moreInfo = `

For more info see ${ref}
`;
  const body = {};
  const minAllowedParams = commandParams.filter((param) => param.required).length;
  if (args2.length < minAllowedParams || args2.length > commandParams.length) {
    const parameterDescription = commandParams.length ? `

Property Description:
${commandParams.map((p) => `  "${p.name}" (${p.type}): ${p.description}`).join("\n")}` : "";
    throw new Error(
      `Wrong parameters applied for ${command}
Usage: ${commandUsage}` + parameterDescription + moreInfo
    );
  }
  for (const [i, arg] of Object.entries(args2)) {
    const commandParam = commandParams[parseInt(i, 10)];
    if (!isValidParameter(arg, commandParam.type)) {
      if (typeof arg === "undefined" && !commandParam.required) {
        continue;
      }
      throw new Error(
        `Malformed type for "${commandParam.name}" parameter of command ${command}
Expected: ${commandParam.type}
Actual: ${getArgumentType(arg)}` + moreInfo
      );
    }
    body[commandParams[parseInt(i, 10)].name] = arg;
  }
  log.info("COMMAND", commandCallStructure(command, args2));
  return body;
};
function getPrototype(commandWrapper) {
  const prototype = {};
  for (const [endpoint, methods] of Object.entries(WebDriverProtocol)) {
    for (const [method, commandData] of Object.entries(methods)) {
      prototype[commandData.command] = { value: commandWrapper(method, endpoint, commandData) };
    }
  }
  return prototype;
}
async function findElement(context, using, value) {
  const implicitTimeout = this.timeouts.get("implicit");
  using === "xpath" ? await context.waitForSelector(`xpath/.${value}`, { timeout: implicitTimeout }) : await context.waitForSelector(value, { timeout: implicitTimeout });
  let element = null;
  try {
    element = using === "xpath" ? (await context.$$(`xpath/.${value}`))[0] : await context.$(value);
  } catch (err) {
    if (!err.message.includes("failed to find element")) {
      throw err;
    }
  }
  if (!element) {
    return new Error(`Element with selector "${value}" not found`);
  }
  const elementId = this.elementStore.set(element);
  return { [ELEMENT_KEY]: elementId };
}
async function findElements(context, using, value) {
  const implicitTimeout = this.timeouts.get("implicit");
  using === "xpath" ? await context.waitForSelector(`xpath/.${value}`, { timeout: implicitTimeout }) : await context.waitForSelector(value, { timeout: implicitTimeout });
  const elements = using === "xpath" ? await context.$$(`xpath/.${value}`) : await context.$$(value);
  if (elements.length === 0) {
    return [];
  }
  return elements.map((element) => ({
    [ELEMENT_KEY]: this.elementStore.set(element)
  }));
}
function sanitizeError(err) {
  let errorMessage = err.message;
  if (err.message.includes("Node is detached from document")) {
    err.name = ERROR_MESSAGES.staleElement.name;
    errorMessage = ERROR_MESSAGES.staleElement.message;
  }
  const stack = err.stack ? err.stack.split("\n") : [];
  const asyncStack = stack.lastIndexOf("  -- ASYNC --");
  err.stack = errorMessage + "\n" + stack.slice(asyncStack + 1).filter((line) => !line.includes("devtools/node_modules/puppeteer-core")).join("\n");
  return err;
}
async function transformExecuteArgs(args2 = []) {
  return Promise.all(args2.map(async (arg) => {
    if (arg && arg[ELEMENT_KEY]) {
      const elementHandle = await this.elementStore.get(arg[ELEMENT_KEY]);
      if (!elementHandle) {
        throw getStaleElementError(arg[ELEMENT_KEY]);
      }
      arg = elementHandle;
    }
    return arg;
  }));
}
async function transformExecuteResult(page, result2) {
  const isResultArray2 = Array.isArray(result2);
  let tmpResult2 = isResultArray2 ? result2 : [result2];
  if (tmpResult2.find((r) => typeof r === "string" && r.startsWith(SERIALIZE_FLAG))) {
    tmpResult2 = await Promise.all(tmpResult2.map(async (r) => {
      if (typeof r === "string" && r.startsWith(SERIALIZE_FLAG)) {
        return findElement.call(this, page, "css selector", `[${SERIALIZE_PROPERTY}="${r}"]`);
      }
      return r;
    }));
    await page.$$eval(`[${SERIALIZE_PROPERTY}]`, cleanUp, SERIALIZE_PROPERTY);
  }
  return isResultArray2 ? tmpResult2 : tmpResult2[0];
}
function getStaleElementError(elementId) {
  const error = new Error(
    `stale element reference: The element with reference ${elementId} is stale; either the element is no longer attached to the DOM, it is not in the current frame context, or the document has been refreshed`
  );
  error.name = "stale element reference";
  return error;
}
async function getPages(browser, retryInterval = 100) {
  const pages = await browser.pages();
  if (pages.length === 0) {
    log.info("no browser pages found, retrying...");
    await new Promise((resolve3) => setTimeout(resolve3, retryInterval));
    return getPages(browser);
  }
  return pages;
}
function sort(installations, priorities) {
  const defaultPriority = 10;
  return installations.map((inst) => {
    for (const pair of priorities) {
      if (pair.regex.test(inst)) {
        return { path: inst, weight: pair.weight };
      }
    }
    return { path: inst, weight: defaultPriority };
  }).sort((a, b) => b.weight - a.weight).map((pair) => pair.path);
}
function uniq(arr) {
  return Array.from(new Set(arr));
}
function findByWhich(executables, priorities) {
  const installations = [];
  executables.forEach((executable) => {
    try {
      const browserPath = which.sync(executable);
      if (canAccess(browserPath)) {
        installations.push(browserPath);
      }
    } catch (err) {
    }
  });
  return sort(uniq(installations.filter(Boolean)), priorities);
}
async function patchDebug(scoppedLogger) {
  const pkgName = "debug";
  try {
    const puppeteerPkg = await resolve("puppeteer-core", import.meta.url);
    let puppeteerDebugPkg = await resolve(pkgName, puppeteerPkg);
    if (!await fs.access(puppeteerDebugPkg).then(() => true, () => false)) {
      puppeteerDebugPkg = await resolve(pkgName, import.meta.url);
    }
    const debug = (await import(puppeteerDebugPkg)).default;
    debug.log = (msg) => {
      if (msg.includes("puppeteer:protocol")) {
        msg = msg.split("\n").map(
          (l) => l.slice(Math.max(l.indexOf("\u25C0 "), l.indexOf("\u25BA "))).replace("\x1B[32m", "").replace("\x1B[39m", "").replace("\u25C0 \x1B[0m", "").replace("\u25BA \x1B[0m", "").trim()
        ).join("").slice(2, -2);
      }
      scoppedLogger.debug(msg);
    };
  } catch (err) {
    log.warn("Couldn't stub Puppeteer debug package, Puppeteer logs might get lost");
  }
}
var sleep = (time = 0) => new Promise(
  (resolve3) => setTimeout(resolve3, time)
);
var launchChromeUsingWhich = async (err, launchOptions) => {
  if (
    /**
     * the installation could not be found
     */
    !err.message.includes("No Chrome installations found.") || /**
     * the user specified a binary path that could not be found
     */
    typeof launchOptions.chromePath === "string"
  ) {
    throw err;
  }
  const errorMessage = "Failed to find a Chrome installation via:\n$ which chrome: %s\n$ which chromium: %s\n$ which google-chrome: %s";
  const chromePath = await which("chrome").catch(
    (errorChrome) => which("chromium").catch(
      (errorChromium) => which("google-chrome").catch((errorGoogleChrome) => {
        throw new Error(util.format(
          errorMessage,
          errorChrome.message,
          errorChromium.message,
          errorGoogleChrome.message
        ));
      })
    )
  );
  return launchChromeBrowser({ ...launchOptions, chromePath });
};

// src/commands/closeWindow.ts
async function closeWindow() {
  delete this.currentFrame;
  const page = this.getPageHandle();
  await page.close();
  await sleep(100);
  const handles = [...this.windows.keys()];
  this.currentWindowHandle = handles[handles.length - 1];
  if (!this.currentWindowHandle) {
    const page2 = await this.browser.newPage();
    const newWindowHandle = uuidv4();
    this.windows.set(newWindowHandle, page2);
    this.currentWindowHandle = newWindowHandle;
  }
  const newPage = this.getPageHandle();
  await newPage.bringToFront();
  return this.currentWindowHandle;
}

// src/scripts/createWindow.ts
function createWindow(url2, features) {
  return window.open(url2, "_blank", features);
}

// src/commands/createWindow.ts
var WINDOW_FEATURES = "menubar=1,toolbar=1,location=1,resizable=1,scrollbars=1";
var NEW_PAGE_URL = "about:blank";
var DEFAULT_WINDOW_TYPE = "tab";
async function createWindow2({ type }) {
  type = type || DEFAULT_WINDOW_TYPE;
  let newPage;
  if (type === "window") {
    const page = this.getPageHandle();
    await page.evaluate(createWindow, NEW_PAGE_URL, WINDOW_FEATURES);
    const newWindowTarget = await this.browser.waitForTarget(
      (target) => target.url() === NEW_PAGE_URL
    );
    newPage = await newWindowTarget.page();
    if (!newPage) {
      throw new Error("Couldn't find page to switch to");
    }
  } else {
    newPage = await this.browser.newPage();
  }
  await newPage.bringToFront();
  return {
    handle: this.currentWindowHandle,
    type
  };
}

// src/commands/deleteAllCookies.ts
async function deleteAllCookies() {
  const page = this.getPageHandle();
  const cookies = await page.cookies();
  for (const cookie of cookies) {
    await page.deleteCookie(cookie);
  }
  return null;
}

// src/commands/deleteCookie.ts
async function deleteCookie({ name }) {
  const page = this.getPageHandle();
  const cookies = await page.cookies();
  const cookieToDelete = cookies.find((cookie) => cookie.name === name);
  if (cookieToDelete) {
    await page.deleteCookie(cookieToDelete);
  }
  return null;
}

// src/commands/deleteSession.ts
async function deleteSession() {
  await this.browser.close();
  this.windows.clear();
  return null;
}

// src/commands/dismissAlert.ts
async function dismissAlert() {
  if (!this.activeDialog) {
    throw new Error("no such alert");
  }
  await this.activeDialog.dismiss();
  delete this.activeDialog;
  return null;
}

// src/scripts/elementClear.ts
function elementClear(html, elem) {
  elem.value = "";
}

// src/commands/elementClear.ts
async function elementClear2({ elementId }) {
  const elementHandle = await this.elementStore.get(elementId);
  if (!elementHandle) {
    throw getStaleElementError(elementId);
  }
  const page = this.getPageHandle(true);
  await page.$eval("html", elementClear, elementHandle);
  return null;
}

// src/scripts/getElementTagName.ts
function getElementTagName(html, elem) {
  return elem.tagName;
}

// src/commands/getElementTagName.ts
async function getElementTagName2({ elementId }) {
  const elementHandle = await this.elementStore.get(elementId);
  if (!elementHandle) {
    throw getStaleElementError(elementId);
  }
  const page = this.getPageHandle(true);
  const result2 = await page.$eval("html", getElementTagName, elementHandle);
  return (result2 || "").toLowerCase();
}

// src/scripts/selectOption.ts
function selectOption(html, elem) {
  elem.selected = true;
  let parent = elem.parentElement;
  while (parent && parent.tagName.toLowerCase() !== "select") {
    parent = parent.parentElement;
  }
  parent.dispatchEvent(new Event("input", { bubbles: true }));
  parent.dispatchEvent(new Event("change", { bubbles: true }));
}

// src/commands/elementClick.ts
async function elementClick({ elementId }) {
  const page = this.getPageHandle();
  const elementHandle = await this.elementStore.get(elementId);
  if (!elementHandle) {
    throw getStaleElementError(elementId);
  }
  const tagName = await getElementTagName2.call(this, { elementId });
  if (tagName === "option") {
    return page.$eval("html", selectOption, elementHandle);
  }
  return new Promise((resolve3, reject) => {
    const dialogHandler = () => resolve3(null);
    page.once("dialog", dialogHandler);
    return elementHandle.click().then(() => {
      page.off("dialog", dialogHandler);
      resolve3(null);
    }).catch(reject);
  });
}

// src/commands/elementSendKeys.ts
import path from "node:path";
import { UNICODE_CHARACTERS as UNICODE_CHARACTERS2 } from "@testplane/wdio-utils";
async function elementSendKeys({ elementId, text }) {
  const elementHandle = await this.elementStore.get(elementId);
  if (!elementHandle) {
    throw getStaleElementError(elementId);
  }
  await elementHandle.focus();
  const page = this.getPageHandle();
  const propertyHandles = {
    tagName: await elementHandle.getProperty("tagName"),
    type: await elementHandle.getProperty("type")
  };
  const tagName = await propertyHandles.tagName?.jsonValue();
  const type = await propertyHandles.type?.jsonValue();
  let typeInput = [text];
  for (const [key, value] of Object.entries(UNICODE_CHARACTERS2)) {
    typeInput = typeInput.reduce((input, val) => [
      ...input,
      ...val.split(value).flatMap(
        (value2, index, array) => array.length - 1 !== index ? [value2, key] : value2
      )
    ], []);
  }
  if (tagName === "INPUT" && type === "file") {
    const paths = (text || "").split("\n").map((p) => path.resolve(p));
    await elementHandle.uploadFile(...paths);
  } else {
    for (const input of typeInput) {
      UNICODE_CHARACTERS2[input] ? await page.keyboard.press(input) : await page.keyboard.type(input);
    }
  }
  return null;
}

// src/scripts/executeAsyncScript.ts
var executeAsyncScript_default = (_, script, scriptTimeout, dataProperty, dataFlag, ...commandArgs) => {
  return new Promise((_resolve, _reject) => {
    setTimeout(
      () => _reject(new Error("Evaluation failed: script timeout")),
      scriptTimeout
    );
    window.arguments = [...commandArgs, (result2) => {
      let tmpResult2 = result2 instanceof NodeList ? Array.from(result2) : result2;
      const isResultArray2 = Array.isArray(tmpResult2);
      tmpResult2 = isResultArray2 ? tmpResult2 : [tmpResult2];
      if (tmpResult2.find((r) => r instanceof HTMLElement)) {
        tmpResult2 = tmpResult2.map((r, i) => {
          if (r instanceof HTMLElement) {
            const dataPropertyValue = `${dataFlag}_${i}`;
            r.setAttribute(dataProperty, dataPropertyValue);
            return dataPropertyValue;
          }
          return r;
        });
      }
      return _resolve(isResultArray2 ? tmpResult2 : tmpResult2[0]);
    }];
    return eval(script);
  });
};

// src/commands/executeAsyncScript.ts
async function executeAsyncScript({ script: script2, args: args2 }) {
  const page = this.getPageHandle(true);
  const scriptTimeout2 = this.timeouts.get("script") || 0;
  script2 = script2.trim();
  if (script2.startsWith("return (")) {
    script2 = script2.slice(7);
  }
  if (script2.startsWith("return")) {
    script2 = `(function () { ${script2} }).apply(null, arguments)`;
  }
  const result2 = await page.$eval(
    "html",
    executeAsyncScript_default,
    script2,
    scriptTimeout2,
    SERIALIZE_PROPERTY,
    SERIALIZE_FLAG,
    ...await transformExecuteArgs.call(this, args2)
  );
  return transformExecuteResult.call(this, page, result2);
}

// src/scripts/executeScript.ts
var executeScript_default = (_, script, dataProperty, dataFlag, ...args) => {
  window.arguments = args;
  const result = eval(script);
  let tmpResult = result instanceof NodeList ? Array.from(result) : result;
  const isResultArray = Array.isArray(tmpResult);
  tmpResult = isResultArray ? tmpResult : [tmpResult];
  if (tmpResult.find((r) => r instanceof HTMLElement)) {
    tmpResult = tmpResult.map((r, i) => {
      if (r instanceof HTMLElement) {
        const dataPropertyValue = `${dataFlag}_${i}`;
        r.setAttribute(dataProperty, dataPropertyValue);
        return dataPropertyValue;
      }
      return r;
    });
  }
  return isResultArray ? tmpResult : tmpResult[0];
};

// src/commands/executeScript.ts
async function executeScript({ script: script2, args: args2 }) {
  const page = this.getPageHandle(true);
  const scriptTimeout2 = this.timeouts.get("script");
  script2 = script2.trim();
  if (script2.startsWith("return (")) {
    script2 = script2.slice(7);
  }
  if (script2.startsWith("return")) {
    script2 = `(function () { ${script2} }).apply(null, arguments)`;
  }
  const executePromise = page.$eval(
    "html",
    executeScript_default,
    script2,
    SERIALIZE_PROPERTY,
    SERIALIZE_FLAG,
    ...await transformExecuteArgs.call(this, args2)
  );
  let executeTimeout;
  const timeoutPromise = new Promise((_2, reject) => {
    executeTimeout = setTimeout(() => {
      const timeoutError = `script timeout${this.activeDialog ? " reason: a browser dialog has opened as result of a executeScript call" : ""}`;
      return reject(new Error(timeoutError));
    }, scriptTimeout2);
  });
  const result2 = await Promise.race([executePromise, timeoutPromise]).finally(() => {
    clearTimeout(executeTimeout);
  });
  return transformExecuteResult.call(this, page, result2);
}

// src/commands/findElementFromElement.ts
async function findElementFromElement({ elementId, using, value }) {
  if (!SUPPORTED_SELECTOR_STRATEGIES.includes(using)) {
    throw new Error(`selector strategy "${using}" is not yet supported`);
  }
  const elementHandle = await this.elementStore.get(elementId);
  if (!elementHandle) {
    throw getStaleElementError(elementId);
  }
  if (using === "link text") {
    using = "xpath";
    value = `.//a[normalize-space() = "${value}"]`;
  } else if (using === "partial link text") {
    using = "xpath";
    value = `.//a[contains(., "${value}")]`;
  } else if (using === "shadow") {
    using = "css";
    value = `shadow/${value}`;
  }
  return findElement.call(this, elementHandle, using, value);
}

// src/commands/findElementFromShadowRoot.ts
async function findElementFromShadowRoot({ shadowId, using, value }) {
  if (using !== "css selector") {
    throw new Error('Fetching elements from a shadow element using something other than "css selector" is currently not supported.');
  }
  return findElementFromElement.call(this, {
    elementId: shadowId,
    using: "shadow",
    value
  });
}

// src/commands/findElementsFromElement.ts
async function findElementFromElements({ elementId, using, value }) {
  if (!SUPPORTED_SELECTOR_STRATEGIES.includes(using)) {
    throw new Error(`selector strategy "${using}" is not yet supported`);
  }
  const elementHandle = await this.elementStore.get(elementId);
  if (!elementHandle) {
    throw getStaleElementError(elementId);
  }
  if (using === "link text") {
    using = "xpath";
    value = `.//a[normalize-space() = "${value}"]`;
  } else if (using === "partial link text") {
    using = "xpath";
    value = `.//a[contains(., "${value}")]`;
  } else if (using === "shadow") {
    using = "css";
    value = `shadow/${value}`;
  }
  return findElements.call(this, elementHandle, using, value);
}

// src/commands/findElementsFromShadowRoot.ts
async function findElementsFromShadowRoot({ shadowId, using, value }) {
  if (using !== "css selector") {
    throw new Error('Fetching elements from a shadow element using something other than "css selector" is currently not supported.');
  }
  return findElementFromElements.call(this, {
    elementId: shadowId,
    using: "shadow",
    value
  });
}

// src/commands/findElements.ts
async function findElements2({ using, value }) {
  if (!SUPPORTED_SELECTOR_STRATEGIES.includes(using)) {
    throw new Error(`selector strategy "${using}" is not yet supported`);
  }
  if (using === "link text") {
    using = "xpath";
    value = `//a[normalize-space() = "${value}"]`;
  } else if (using === "partial link text") {
    using = "xpath";
    value = `//a[contains(., "${value}")]`;
  } else if (using === "shadow") {
    using = "css";
    value = `shadow/${value}`;
  }
  const page = this.getPageHandle(true);
  return findElements.call(this, page, using, value);
}

// src/commands/findElement.ts
function findElement2({ using, value }) {
  if (!SUPPORTED_SELECTOR_STRATEGIES.includes(using)) {
    throw new Error(`selector strategy "${using}" is not yet supported`);
  }
  if (using === "link text") {
    using = "xpath";
    value = `//a[normalize-space() = "${value}"]`;
  } else if (using === "partial link text") {
    using = "xpath";
    value = `//a[contains(., "${value}")]`;
  } else if (using === "shadow") {
    using = "css";
    value = `shadow/${value}`;
  }
  const page = this.getPageHandle(true);
  return findElement.call(this, page, using, value);
}

// src/commands/forward.ts
async function forward() {
  delete this.currentFrame;
  const page = this.getPageHandle();
  await page.goForward();
  return null;
}

// src/scripts/getActiveElement.ts
function getActiveElement(_2, dataProperty2) {
  if (!document.activeElement) {
    return false;
  }
  document.activeElement.setAttribute(dataProperty2, "true");
  return true;
}

// src/commands/getActiveElement.ts
async function getActiveElement2() {
  const page = this.getPageHandle(true);
  const selector = `[${SERIALIZE_PROPERTY}]`;
  const hasElem = await page.$eval("html", getActiveElement, SERIALIZE_PROPERTY);
  if (!hasElem) {
    throw new Error("no element active");
  }
  const activeElement = await findElement2.call(this, {
    using: "css selector",
    value: selector
  });
  await page.$eval(selector, cleanUp, SERIALIZE_PROPERTY);
  return activeElement;
}

// src/commands/getAlertText.ts
function getAlertText() {
  if (!this.activeDialog) {
    throw new Error("no such alert");
  }
  return this.activeDialog.message();
}

// src/commands/getAllCookies.ts
async function getAllCookies() {
  const page = this.getPageHandle();
  return page.cookies();
}

// src/scripts/getElementAttribute.ts
function getElementAttribute(_2, elem, attr) {
  return elem.getAttribute(attr);
}

// src/commands/getElementAttribute.ts
async function getElementAttribute2({ elementId, name }) {
  const elementHandle = await this.elementStore.get(elementId);
  if (!elementHandle) {
    throw getStaleElementError(elementId);
  }
  const page = this.getPageHandle(true);
  return page.$eval("html", getElementAttribute, elementHandle, name);
}

// src/commands/getElementComputedLabel.ts
async function getElementComputedLabel({ elementId }) {
  const page = this.getPageHandle(true);
  const elementHandle = await this.elementStore.get(elementId);
  const snapshot = await page.accessibility.snapshot({
    root: elementHandle
  });
  if (!snapshot) {
    return "";
  }
  return snapshot.name;
}

// src/commands/getElementComputedRole.ts
async function getElementComputedRole({ elementId }) {
  const page = this.getPageHandle(true);
  const elementHandle = await this.elementStore.get(elementId);
  const snapshot = await page.accessibility.snapshot({
    root: elementHandle
  });
  if (!snapshot) {
    return "Ignored";
  }
  return snapshot.role;
}

// src/scripts/getElementCSSValue.ts
function getElementCSSValue(_2, elem, propertyName) {
  return window.getComputedStyle(elem)[propertyName];
}

// src/commands/getElementCSSValue.ts
async function getElementCSSValue2({ elementId, propertyName }) {
  const elementHandle = await this.elementStore.get(elementId);
  if (!elementHandle) {
    throw getStaleElementError(elementId);
  }
  const page = this.getPageHandle(true);
  return page.$eval("html", getElementCSSValue, elementHandle, propertyName);
}

// src/commands/getElementProperty.ts
async function getElementProperty({ elementId, name }) {
  const elementHandle = await this.elementStore.get(elementId);
  if (!elementHandle) {
    throw getStaleElementError(elementId);
  }
  const jsHandle = await elementHandle.getProperty(name);
  if (!jsHandle) {
    return null;
  }
  return jsHandle.jsonValue();
}

// src/scripts/getElementRect.ts
function getElementRect(html, elem) {
  const { x, y, width, height } = elem.getBoundingClientRect();
  return { x, y, width, height };
}

// src/commands/getElementRect.ts
async function getElementRect2({ elementId }) {
  const elementHandle = await this.elementStore.get(elementId);
  if (!elementHandle) {
    throw getStaleElementError(elementId);
  }
  const page = this.getPageHandle(true);
  return page.$eval("html", getElementRect, elementHandle);
}

// src/commands/getElementShadowRoot.ts
async function getElementShadowRoot({ elementId }) {
  const elementHandle = await this.elementStore.get(elementId);
  if (!elementHandle) {
    throw getStaleElementError(elementId);
  }
  return { [SHADOW_ELEMENT_KEY]: elementId };
}

// src/scripts/getElementText.ts
function getElementText(html, elem) {
  return elem.innerText;
}

// src/commands/getElementText.ts
async function getElementText2({ elementId }) {
  const elementHandle = await this.elementStore.get(elementId);
  if (!elementHandle) {
    throw getStaleElementError(elementId);
  }
  const page = this.getPageHandle(true);
  return page.$eval("html", getElementText, elementHandle);
}

// src/commands/getNamedCookie.ts
async function getNamedCookie({ name }) {
  const page = this.getPageHandle();
  const cookies = await page.cookies();
  const cookie = cookies.find((cookie2) => cookie2.name === name);
  if (!cookie) {
    throw new Error(`No cookie with name ${name}`);
  }
  return cookie;
}

// src/commands/getPageSource.ts
function getPageSource() {
  const page = this.getPageHandle(true);
  return page.content();
}

// src/commands/getTimeouts.ts
function getTimeouts() {
  return {
    implicit: this.timeouts.get("implicit"),
    pageLoad: this.timeouts.get("pageLoad"),
    script: this.timeouts.get("script")
  };
}

// src/commands/getTitle.ts
async function getTitle() {
  const page = this.getPageHandle(true);
  return page.title();
}

// src/scripts/getUrl.ts
function getUrl() {
  return document.location.href;
}

// src/commands/getUrl.ts
async function getUrl2() {
  const page = this.getPageHandle(true);
  return page.$eval("html", getUrl);
}

// src/commands/getWindowHandles.ts
async function getWindowHandles() {
  return Array.from(this.windows.keys());
}

// src/commands/getWindowHandle.ts
async function getWindowHandle() {
  return this.currentWindowHandle;
}

// src/commands/getWindowRect.ts
async function getWindowRect() {
  const page = this.getPageHandle();
  const viewport = await page.viewport() || {};
  return Object.assign(
    { width: DEFAULT_WIDTH, height: DEFAULT_HEIGHT, x: 0, y: 0 },
    viewport
  );
}

// src/commands/isElementEnabled.ts
async function isElementEnabled({ elementId }) {
  const result2 = await getElementAttribute2.call(this, { elementId, name: "disabled" });
  return result2 === null;
}

// src/commands/isElementSelected.ts
async function isElementSelected({ elementId }) {
  const tagName = await getElementTagName2.call(this, { elementId });
  const name = tagName === "option" ? "selected" : "checked";
  const isSelected = await getElementProperty.call(this, { elementId, name });
  return Boolean(isSelected);
}

// src/commands/navigateTo.ts
async function navigateTo({ url: url2 }) {
  delete this.currentFrame;
  const page = this.getPageHandle();
  await page.goto(url2);
  return null;
}

// src/commands/newSession.ts
import os3 from "node:os";
import { v4 as uuidv42 } from "uuid";

// src/launcher.ts
import { launch as launchChromeBrowser2 } from "chrome-launcher";
import puppeteer, { KnownDevices, Puppeteer } from "puppeteer-core";
import logger2 from "@testplane/wdio-logger";
import { QueryHandler } from "query-selector-shadow-dom/plugins/puppeteer/index.js";

// src/finder/edge.ts
import os from "node:os";
import path3 from "node:path";
import { execSync as execSync2 } from "node:child_process";
import { getEdgePath } from "edge-paths";
import { canAccess as canAccess3 } from "@testplane/wdio-utils/node";

// src/finder/finder.ts
import path2 from "node:path";
import { execSync } from "node:child_process";
import { canAccess as canAccess2 } from "@testplane/wdio-utils/node";
var DARWIN_LIST_APPS = "system_profiler SPApplicationsDataType -json";
var darwinGetAppPaths = (app) => {
  const apps = JSON.parse(execSync(DARWIN_LIST_APPS).toString());
  const appPaths = apps.SPApplicationsDataType.filter((inst) => inst.info && inst.info.startsWith(app)).map((inst) => inst.path);
  return appPaths;
};
var darwinGetInstallations = (appPaths, suffixes) => {
  const installations = [];
  appPaths.forEach((inst) => {
    suffixes.forEach((suffix) => {
      const execPath = path2.join(inst.substring(0, inst.indexOf(".app") + 4).trim(), suffix);
      if (canAccess2(execPath) && installations.indexOf(execPath) === -1) {
        installations.push(execPath);
      }
    });
  });
  return installations;
};

// src/finder/edge.ts
var newLineRegex = /\r?\n/;
var EDGE_BINARY_NAMES = ["edge", "msedge", "microsoft-edge", "microsoft-edge-dev"];
var EDGE_REGEX = /((ms|microsoft))?edge/g;
function darwin() {
  const suffixes = [
    "/Contents/MacOS/Microsoft Edge"
  ];
  const appName = "Microsoft Edge";
  const defaultPath = `/Applications/${appName}.app${suffixes[0]}`;
  let installations;
  if (canAccess3(defaultPath)) {
    installations = [defaultPath];
  } else {
    const appPaths = darwinGetAppPaths(appName);
    installations = darwinGetInstallations(appPaths, suffixes);
  }
  const priorities = [
    { regex: new RegExp(`^${process.env.HOME}/Applications/.*Microsoft Edge.app`), weight: 50 },
    { regex: /^\/Applications\/.*Microsoft Edge.app/, weight: 100 },
    { regex: /^\/Volumes\/.*Microsoft Edge.app/, weight: -2 }
  ];
  const whichFinds = findByWhich(
    EDGE_BINARY_NAMES,
    [{ regex: EDGE_REGEX, weight: 51 }]
  );
  const installFinds = sort(installations, priorities);
  return [...installFinds, ...whichFinds];
}
function linux() {
  let installations = [];
  const desktopInstallationFolders = [
    path3.join(os.homedir(), ".local/share/applications/"),
    "/usr/share/applications/"
  ];
  desktopInstallationFolders.forEach((folder) => {
    installations = installations.concat(findEdgeExecutables(folder));
  });
  return findByWhich(
    EDGE_BINARY_NAMES,
    [{ regex: EDGE_REGEX, weight: 51 }]
  );
}
function win32() {
  const installations = [];
  const suffixes = [
    `${path3.sep}Microsoft${path3.sep}Edge${path3.sep}Application${path3.sep}edge.exe`,
    `${path3.sep}Microsoft${path3.sep}Edge${path3.sep}Application${path3.sep}msedge.exe`,
    `${path3.sep}Microsoft${path3.sep}Edge Dev${path3.sep}Application${path3.sep}msedge.exe`
  ];
  const prefixes = [
    process.env.LOCALAPPDATA || "",
    process.env.PROGRAMFILES || "",
    process.env["PROGRAMFILES(X86)"] || ""
  ].filter(Boolean);
  const checkedPath = [];
  prefixes.forEach((prefix) => suffixes.forEach((suffix) => {
    const edgePath = path3.join(prefix, suffix);
    checkedPath.push(edgePath);
    if (canAccess3(edgePath)) {
      installations.push(edgePath);
    }
  }));
  if (installations.length === 0) {
    const edgePath = getEdgePath();
    if (canAccess3(edgePath)) {
      installations.push(edgePath);
    }
  }
  return installations;
}
function findEdgeExecutables(folder) {
  const argumentsRegex = /(^[^ ]+).*/;
  const edgeExecRegex = "^Exec=/.*/(edge)-.*";
  const installations = [];
  if (canAccess3(folder)) {
    let execPaths;
    try {
      execPaths = execSync2(
        `grep -ER "${edgeExecRegex}" ${folder} | awk -F '=' '{print $2}'`,
        { stdio: "pipe" }
      );
    } catch (err) {
      execPaths = execSync2(
        `grep -Er "${edgeExecRegex}" ${folder} | awk -F '=' '{print $2}'`,
        { stdio: "pipe" }
      );
    }
    execPaths = execPaths.toString().split(newLineRegex).map(
      (execPath) => execPath.replace(argumentsRegex, "$1")
    );
    execPaths.forEach((execPath) => canAccess3(execPath) && installations.push(execPath));
  }
  return installations;
}
var edge_default = {
  darwin,
  linux,
  win32
};

// src/finder/firefox.ts
import os2 from "node:os";
import path4 from "node:path";
import { execSync as execSync3 } from "node:child_process";
import { canAccess as canAccess4 } from "@testplane/wdio-utils/node";
var newLineRegex2 = /\r?\n/;
function darwin2() {
  const suffixes = [
    "/Contents/MacOS/firefox-bin"
  ];
  const appName = "Firefox Nightly";
  const defaultPath = `/Applications/${appName}.app${suffixes[0]}`;
  let installations;
  if (canAccess4(defaultPath)) {
    installations = [defaultPath];
  } else {
    const appPaths = darwinGetAppPaths(appName);
    installations = darwinGetInstallations(appPaths, suffixes);
  }
  const priorities = [
    { regex: new RegExp(`^${process.env.HOME}/Applications/.*Firefox.app`), weight: 50 },
    { regex: /^\/Applications\/.*Firefox.app/, weight: 100 },
    { regex: /^\/Volumes\/.*Firefox.app/, weight: -2 }
  ];
  const whichFinds = findByWhich(
    ["firefox-nightly", "firefox-trunk"],
    [{ regex: /firefox-nightly/, weight: 51 }]
  );
  const installFinds = sort(installations, priorities);
  return [...installFinds, ...whichFinds];
}
function linux2() {
  let installations = [];
  const desktopInstallationFolders = [
    path4.join(os2.homedir(), ".local/share/applications/"),
    "/usr/share/applications/"
  ];
  desktopInstallationFolders.forEach((folder) => {
    installations = installations.concat(findFirefoxExecutables(folder));
  });
  const whichFinds = findByWhich(
    ["firefox-nightly", "firefox-trunk", "firefox"],
    [{ regex: /firefox/, weight: 51 }]
  );
  return [...installations, ...whichFinds];
}
function win322() {
  const installations = [];
  const suffixes = [
    `${path4.sep}Firefox Nightly${path4.sep}Application${path4.sep}firefox.exe`
  ];
  const prefixes = [
    process.env.LOCALAPPDATA || "",
    process.env.PROGRAMFILES || "",
    process.env["PROGRAMFILES(X86)"] || ""
  ].filter(Boolean);
  prefixes.forEach((prefix) => suffixes.forEach((suffix) => {
    const firefoxPath = path4.join(prefix, suffix);
    if (canAccess4(firefoxPath)) {
      installations.push(firefoxPath);
    }
  }));
  return installations;
}
function findFirefoxExecutables(folder) {
  const argumentsRegex = /(^[^ ]+).*/;
  const edgeExecRegex = "^Exec=/.*/(firefox)-.*";
  const installations = [];
  if (canAccess4(folder)) {
    let execPaths;
    try {
      execPaths = execSync3(
        `grep -ER "${edgeExecRegex}" ${folder} | awk -F '=' '{print $2}'`,
        { stdio: "pipe" }
      );
    } catch (err) {
      execPaths = execSync3(
        `grep -Er "${edgeExecRegex}" ${folder} | awk -F '=' '{print $2}'`,
        { stdio: "pipe" }
      );
    }
    execPaths = execPaths.toString().split(newLineRegex2).map(
      (execPath) => execPath.replace(argumentsRegex, "$1")
    );
    execPaths.forEach((execPath) => canAccess4(execPath) && installations.push(execPath));
  }
  return installations;
}
var firefox_default = {
  darwin: darwin2,
  linux: linux2,
  win32: win322
};

// src/finder/index.ts
var finder_default = (browserName, platform) => {
  const finder = {
    firefox: firefox_default,
    edge: edge_default
  }[browserName];
  const supportedPlatforms = Object.keys(finder);
  if (!supportedPlatforms.includes(platform)) {
    throw new Error(`Operating system ("${process.platform}") is not supported`);
  }
  return finder[platform];
};

// src/launcher.ts
var log2 = logger2("devtools");
var DEVICE_NAMES = Object.keys(KnownDevices);
async function launchChrome(capabilities) {
  const chromeOptions = capabilities[VENDOR_PREFIX.chrome] || {};
  const mobileEmulation = chromeOptions.mobileEmulation || {};
  const devtoolsOptions = capabilities["wdio:devtoolsOptions"] || {};
  const chromeOptionsArgs = (chromeOptions.args || []).map((arg) => arg.startsWith("--") ? arg : `--${arg}`);
  const ignoreDefaultArgs = capabilities.ignoreDefaultArgs || devtoolsOptions.ignoreDefaultArgs;
  const headless = chromeOptions.headless || devtoolsOptions.headless;
  if (typeof mobileEmulation.deviceName === "string") {
    const deviceProperties = KnownDevices[mobileEmulation.deviceName];
    if (!deviceProperties) {
      throw new Error(`Unknown device name "${mobileEmulation.deviceName}", available: ${DEVICE_NAMES.join(", ")}`);
    }
    mobileEmulation.userAgent = deviceProperties.userAgent;
    mobileEmulation.deviceMetrics = {
      width: deviceProperties.viewport.width,
      height: deviceProperties.viewport.height,
      pixelRatio: deviceProperties.viewport.deviceScaleFactor
    };
  }
  let userDataDir;
  const userDataDirIndex = chromeOptionsArgs.findIndex((arg) => arg.includes("user-data-dir"));
  if (userDataDirIndex > -1) {
    userDataDir = chromeOptionsArgs[userDataDirIndex].split("=").pop();
    chromeOptionsArgs.splice(userDataDirIndex, 1);
  }
  const defaultFlags = Array.isArray(ignoreDefaultArgs) ? DEFAULT_FLAGS.filter((flag) => !ignoreDefaultArgs.includes(flag)) : !ignoreDefaultArgs ? DEFAULT_FLAGS : [];
  const deviceMetrics = mobileEmulation.deviceMetrics || devtoolsOptions.defaultViewport && {
    width: devtoolsOptions.defaultViewport.width,
    height: devtoolsOptions.defaultViewport.height,
    pixelRatio: devtoolsOptions.defaultViewport.deviceScaleFactor,
    touch: devtoolsOptions.defaultViewport.isMobile
  } || {};
  const windowFlags = devtoolsOptions.defaultViewport !== null ? [`--window-position=${DEFAULT_X_POSITION},${DEFAULT_Y_POSITION}`, `--window-size=${deviceMetrics?.width || DEFAULT_WIDTH},${deviceMetrics?.height || DEFAULT_HEIGHT}`] : [];
  const chromeFlags = [
    ...defaultFlags,
    ...windowFlags,
    ...headless ? [
      "--headless",
      "--no-sandbox"
    ] : [],
    ...chromeOptionsArgs
  ];
  if (typeof deviceMetrics.pixelRatio === "number") {
    chromeFlags.push(`--device-scale-factor=${deviceMetrics.pixelRatio}`);
  }
  if (typeof mobileEmulation.userAgent === "string") {
    chromeFlags.push(`--user-agent=${mobileEmulation.userAgent}`);
  }
  if (deviceMetrics?.touch) {
    chromeFlags.push(
      "--enable-touch-drag-drop",
      "--touch-events",
      "--enable-viewport"
    );
  }
  if (capabilities.acceptInsecureCerts || devtoolsOptions.ignoreHTTPSErrors) {
    chromeFlags.push("--ignore-certificate-errors");
  }
  log2.info(`Launch Google Chrome (${chromeOptions.binary}) with flags: ${chromeFlags.join(" ")}`);
  const launchOptions = {
    prefs: chromeOptions.prefs,
    chromePath: chromeOptions.binary,
    ignoreDefaultFlags: true,
    chromeFlags,
    userDataDir,
    envVars: devtoolsOptions.env,
    ...devtoolsOptions.customPort ? { port: devtoolsOptions.customPort } : {}
  };
  const chrome = await launchChromeBrowser2(launchOptions).catch(
    (err) => launchChromeUsingWhich(err, launchOptions)
  );
  log2.info(`Connect Puppeteer with browser on port ${chrome.port}`);
  const browser = await puppeteer.connect({
    ...chromeOptions,
    ...devtoolsOptions,
    defaultViewport: null,
    browserURL: `http://127.0.0.1:${chrome.port}`
  });
  const pages = await getPages(browser);
  for (const page of pages.slice(0, -1)) {
    if (page.url() === "about:blank") {
      await page.close();
    }
  }
  return browser;
}
function launchBrowser(capabilities, browserType) {
  const product = browserType === BROWSER_TYPE.firefox ? BROWSER_TYPE.firefox : BROWSER_TYPE.chrome;
  const vendorCapKey = VENDOR_PREFIX[browserType];
  const devtoolsOptions = capabilities["wdio:devtoolsOptions"] || {};
  const ignoreDefaultArgs = capabilities.ignoreDefaultArgs || devtoolsOptions.ignoreDefaultArgs;
  const headless = capabilities.headless || devtoolsOptions.headless;
  devtoolsOptions.ignoreHTTPSErrors = browserType === "firefox" ? Boolean(devtoolsOptions.ignoreHTTPSErrors || capabilities.acceptInsecureCerts) : devtoolsOptions.ignoreHTTPSErrors ?? false;
  if (!capabilities[vendorCapKey]) {
    capabilities[vendorCapKey] = {};
  }
  const browserFinderMethod = finder_default(browserType, process.platform);
  const executablePath = capabilities[vendorCapKey]?.binary || browserFinderMethod()[0];
  const puppeteerOptions = Object.assign({
    product,
    executablePath,
    ignoreDefaultArgs,
    headless: Boolean(headless),
    defaultViewport: {
      width: DEFAULT_WIDTH,
      height: DEFAULT_HEIGHT
    },
    prefs: capabilities[vendorCapKey]?.prefs,
    args: [
      // Set args to honor both ignoreHTTPSErrors  and acceptInsecureCerts
      // Only for WebKit/Blink engines, Firefox uses a different option
      ...["--ignore-certificate-errors"].filter(() => browserType === "edge" && (devtoolsOptions.ignoreHTTPSErrors || capabilities.acceptInsecureCerts))
    ]
  }, capabilities[vendorCapKey] || {}, devtoolsOptions || {});
  if (!executablePath) {
    throw new Error("Couldn't find executable for browser");
  }
  log2.info(`Launch ${executablePath} with config: ${JSON.stringify(puppeteerOptions)}`);
  return puppeteer.launch(puppeteerOptions);
}
function connectBrowser(connectionUrl, capabilities) {
  const connectionProp = connectionUrl.startsWith("http") ? "browserURL" : "browserWSEndpoint";
  const devtoolsOptions = capabilities["wdio:devtoolsOptions"];
  const options = {
    [connectionProp]: connectionUrl,
    ...devtoolsOptions
  };
  return puppeteer.connect(options);
}
async function launch(capabilities) {
  try {
    Puppeteer.unregisterCustomQueryHandler("shadow");
  } catch {
  }
  Puppeteer.registerCustomQueryHandler("shadow", QueryHandler);
  const browserName = capabilities.browserName?.toLowerCase();
  const browserOptions = capabilities["goog:chromeOptions"] || capabilities["ms:edgeOptions"];
  const devtoolsOptions = capabilities["wdio:devtoolsOptions"] || {};
  const connectionUrl = browserOptions?.debuggerAddress && `http://${browserOptions?.debuggerAddress}` || devtoolsOptions.browserURL || devtoolsOptions.browserWSEndpoint;
  if (connectionUrl) {
    return connectBrowser(connectionUrl, capabilities);
  }
  if (!process.env.PROGRAMFILES && process.env.ProgramFiles) {
    process.env.PROGRAMFILES = process.env.ProgramFiles;
  }
  const programFiles86 = process.env["ProgramFiles(X86)"] || process.env["ProgramFiles(x86)"];
  if (!process.env["PROGRAMFILES(X86)"] && programFiles86) {
    process.env["PROGRAMFILES(X86)"] = programFiles86;
  }
  if (browserName && CHROME_NAMES.includes(browserName)) {
    return launchChrome(capabilities);
  }
  if (browserName && FIREFOX_NAMES.includes(browserName)) {
    return launchBrowser(capabilities, BROWSER_TYPE.firefox);
  }
  if (browserName && EDGE_NAMES.includes(browserName)) {
    return launchBrowser(capabilities, BROWSER_TYPE.edge);
  }
  throw new Error(`Couldn't identify browserName "${browserName}"`);
}

// src/commands/newSession.ts
async function newSession({ capabilities }) {
  const browser = await launch(capabilities);
  const sessionId = uuidv42();
  const [browserName, browserVersion] = (await browser.version()).split("/");
  sessionMap.set(sessionId, browser);
  return {
    sessionId,
    capabilities: {
      browserName,
      browserVersion,
      platformName: os3.platform(),
      platformVersion: os3.release()
    }
  };
}

// src/commands/performActions.ts
import { _keyDefinitions } from "puppeteer-core/lib/esm/puppeteer/common/USKeyboardLayout.js";
var KEY = "key";
var POINTER = "pointer";
async function performActions({ actions }) {
  const page = this.getPageHandle();
  const lastPointer = {};
  for (const action of actions) {
    if (action.type === null || action.type === "null") {
      for (const singleAction of action.actions) {
        await sleep(singleAction.duration);
      }
      continue;
    }
    if (action.type === "key") {
      const skipChars = [];
      for (const singleAction of action.actions) {
        if (singleAction.type === "pause") {
          await sleep(singleAction.duration);
          continue;
        }
        const cmd = singleAction.type.slice(KEY.length).toLowerCase();
        const keyboardFn = page.keyboard[cmd].bind(page.keyboard);
        if (cmd === "up" && skipChars[0] === singleAction.value) {
          skipChars.shift();
          continue;
        }
        const [key] = Object.entries(UNICODE_CHARACTERS).find(([, charValue]) => charValue === singleAction.value) || [];
        const pptrKey = key && _keyDefinitions[key] ? key : _keyDefinitions[singleAction.value] ? singleAction.value : void 0;
        if (!pptrKey) {
          await page.keyboard.sendCharacter(singleAction.value);
          skipChars.push(singleAction.value);
          continue;
        }
        await keyboardFn(pptrKey);
        continue;
      }
      continue;
    }
    if (action.type === "pointer") {
      if (action.parameters && action.parameters.pointerType && action.parameters.pointerType !== "mouse") {
        throw new Error('Currently only "mouse" is supported as pointer type');
      }
      if (action.actions.length === 6 && action.actions[0].type === "pointerMove" && action.actions[1].type === "pointerDown" && action.actions[2].type === "pointerUp" && action.actions[3].type === "pause" && action.actions[4].type === "pointerDown" && action.actions[5].type === "pointerUp") {
        let x = action.actions[0].x || 0;
        let y = action.actions[0].y || 0;
        if (action.actions[0].origin) {
          const location = await getElementRect2.call(this, { elementId: action.actions[0].origin[ELEMENT_KEY] });
          x += location.x + location.width / 2;
          y += location.y + location.height / 2;
        }
        await page.mouse.click(x, y, { clickCount: 2 });
        continue;
      }
      for (const singleAction of action.actions) {
        if (singleAction.type === "pause") {
          await sleep(singleAction.duration);
          continue;
        }
        const cmd = singleAction.type.slice(POINTER.length).toLowerCase();
        const keyboardFn = page.mouse[cmd].bind(page.mouse);
        const { duration, button, origin } = singleAction;
        let { x, y } = singleAction;
        if (cmd === "move") {
          if (typeof x === "number" && typeof y === "number" && origin === "pointer" && lastPointer.x && lastPointer.y) {
            x += lastPointer.x;
            y += lastPointer.y;
          }
          if (origin && typeof origin[ELEMENT_KEY] === "string" && typeof x === "number" && typeof y === "number") {
            const elemRect = await getElementRect2.call(this, { elementId: origin[ELEMENT_KEY] });
            x += elemRect.x + elemRect.width / 2;
            y += elemRect.y + elemRect.height / 2;
          }
          lastPointer.x = x;
          lastPointer.y = y;
          await keyboardFn(x, y, { steps: 10 });
          continue;
        } else {
          const pptrButton = button === 1 ? "middle" : button === 2 ? "right" : "left";
          await keyboardFn({ button: pptrButton });
        }
        if (duration) {
          await sleep(duration);
        }
        continue;
      }
      continue;
    }
    if (action.type === "wheel") {
      for (const singleAction of action.actions) {
        const deltaX = singleAction.deltaX || 0;
        const deltaY = singleAction.deltaY || 0;
        if (singleAction.origin) {
          const windowSize = await getWindowRect.call(this);
          const location = await getElementRect2.call(this, { elementId: singleAction.origin[ELEMENT_KEY] });
          await page.mouse.wheel({
            deltaX: location.x + deltaX,
            deltaY: location.y - windowSize.height + deltaY
          });
        } else if (singleAction.x || singleAction.y) {
          await page.mouse.wheel({
            deltaX: (singleAction.x || 0) + deltaX,
            deltaY: (singleAction.y || 0) + deltaY
          });
        } else {
          await page.mouse.wheel({ deltaX, deltaY });
        }
      }
      continue;
    }
    throw new Error(`Unknown action type ("${action.type}"), allowed are only: null, key and pointer`);
  }
}

// src/commands/refresh.ts
async function refresh() {
  delete this.currentFrame;
  const page = this.getPageHandle();
  await page.reload();
  return null;
}

// src/commands/releaseActions.ts
async function performActions2() {
}

// src/commands/sendAlertText.ts
async function sendAlertText({ text }) {
  if (!this.activeDialog) {
    throw new Error("no such alert");
  }
  await this.activeDialog.accept(text);
  delete this.activeDialog;
  return null;
}

// src/commands/setTimeouts.ts
async function setTimeouts({ implicit, pageLoad, script: script2 }) {
  await this.setTimeouts(implicit, pageLoad, script2);
  return null;
}

// src/commands/setWindowRect.ts
async function setWindowRect(params) {
  const page = this.getPageHandle();
  await page.setViewport(params);
  return { width: params.width, height: params.height };
}

// src/commands/status.ts
import fs2 from "node:fs/promises";
import url from "node:url";
import path5 from "node:path";
import { resolve as resolve2 } from "import-meta-resolve";
var puppeteerVersion;
async function status() {
  if (!puppeteerVersion) {
    const puppeteerPath = await resolve2("puppeteer-core", import.meta.url);
    try {
      const pkgJsonPath = path5.resolve(url.fileURLToPath(puppeteerPath), "..", "..", "..", "..", "package.json");
      const pkgJson = JSON.parse((await fs2.readFile(pkgJsonPath, "utf-8")).toString());
      puppeteerVersion = pkgJson.version;
    } catch (err) {
    }
  }
  return {
    message: "",
    ready: true,
    puppeteerVersion
  };
}

// src/commands/switchToFrame.ts
async function switchToFrame({ id }) {
  const page = this.getPageHandle(true);
  if (id === null) {
    if (typeof page.parentFrame !== "function") {
      return { id: null };
    }
    let parentFrame = await page.parentFrame();
    while (parentFrame) {
      parentFrame = await parentFrame.parentFrame();
    }
    this.currentFrame = parentFrame;
    return { id: null };
  }
  if (typeof id === "object" && typeof id[ELEMENT_KEY] === "string") {
    const elementHandle = await this.elementStore.get(id[ELEMENT_KEY]);
    if (!elementHandle) {
      throw getStaleElementError(id[ELEMENT_KEY]);
    }
    const contentFrame = await elementHandle.contentFrame();
    if (!contentFrame) {
      throw new Error("no such frame");
    }
    this.currentFrame = contentFrame;
    return { id: id[ELEMENT_KEY] };
  }
  if (typeof id === "number") {
    const getFrames = page.frames || page.childFrames;
    const childFrames = await getFrames.apply(page);
    const childFrame = childFrames[id];
    if (!childFrame) {
      throw new Error("no such frame");
    }
    this.currentFrame = childFrame;
    return { id: childFrame._id };
  }
  throw new Error(`Could not switch frame, unknown id: ${id}`);
}

// src/commands/switchToParentFrame.ts
async function switchToParentFrame() {
  const page = this.getPageHandle(true);
  if (typeof page.parentFrame !== "function") {
    return null;
  }
  this.currentFrame = await page.parentFrame();
  return null;
}

// src/commands/switchToWindow.ts
async function switchToWindow({ handle }) {
  if (!this.windows.has(handle)) {
    throw new Error(`window with handle ${handle} not found`);
  }
  delete this.currentFrame;
  this.currentWindowHandle = handle;
  const page = this.getPageHandle();
  page.on("dialog", this.dialogHandler.bind(this));
  await page.bringToFront();
  return handle;
}

// src/commands/takeElementScreenshot.ts
async function takeElementScreenshot({ elementId }) {
  const elementHandle = await this.elementStore.get(elementId);
  if (!elementHandle) {
    throw getStaleElementError(elementId);
  }
  return elementHandle.screenshot({
    captureBeyondViewport: false,
    encoding: "base64",
    type: "png"
  });
}

// src/commands/takeScreenshot.ts
async function takeScreenshot() {
  const page = this.getPageHandle();
  return page.screenshot({
    captureBeyondViewport: false,
    encoding: "base64",
    fullPage: false,
    // limit to viewport
    type: "png"
  });
}

// src/elementstore.ts
var ElementStore = class {
  _index = 0;
  _elementMap = /* @__PURE__ */ new Map();
  _frameMap = /* @__PURE__ */ new Map();
  set(elementHandle) {
    const index = `ELEMENT-${++this._index}`;
    this._elementMap.set(index, elementHandle);
    const frame = elementHandle.frame;
    if (frame) {
      let elementIndexes = this._frameMap.get(frame);
      if (!elementIndexes) {
        elementIndexes = /* @__PURE__ */ new Set();
        this._frameMap.set(frame, elementIndexes);
      }
      elementIndexes.add(index);
    }
    return index;
  }
  async get(index) {
    const elementHandle = this._elementMap.get(index);
    if (!elementHandle) {
      return elementHandle;
    }
    const isElementAttachedToDOM = await elementHandle.evaluate((el) => {
      return el.isConnected;
    });
    return isElementAttachedToDOM ? elementHandle : void 0;
  }
  clear(frame) {
    if (!frame) {
      this._elementMap.clear();
      this._frameMap.clear();
      return;
    }
    const elementIndexes = this._frameMap.get(frame);
    if (elementIndexes) {
      elementIndexes.forEach((elementIndex) => this._elementMap.delete(elementIndex));
      this._frameMap.delete(frame);
    }
  }
};

// src/devtoolsdriver.ts
var log3 = logger3("devtools");
var DevToolsDriver = class {
  commands = {};
  elementStore = new ElementStore();
  windows = /* @__PURE__ */ new Map();
  timeouts = /* @__PURE__ */ new Map();
  activeDialog = void 0;
  browser;
  currentFrame;
  currentWindowHandle;
  currentFrameUrl;
  activeListeners = [];
  constructor(browser, pages) {
    this.browser = browser;
    this.commands = commands_exports;
    this.initBrowser(browser, pages);
  }
  _createWindowHandle(page) {
    const pageId = uuidv43();
    this.windows.set(pageId, page);
    this.currentFrame = page;
    this.currentWindowHandle = pageId;
  }
  async _targetCreatedHandler(target) {
    const page = await target.page();
    if (!page) {
      return;
    }
    this._createWindowHandle(page);
  }
  async _targetDestroyedHandler(target) {
    const page = await target.page();
    for (const [pageId, p] of this.windows.entries()) {
      if (page !== p) {
        continue;
      }
      log3.trace(`Target destroyed, removing window handle ${pageId}`);
      this.windows.delete(pageId);
      break;
    }
    const pageIds = [...this.windows.keys()];
    this.currentFrame = this.windows.get(pageIds[0]);
    this.currentWindowHandle = pageIds[0];
    log3.trace(`Switching to window handle with id ${pageIds[0]}`);
  }
  addListener(emitter, eventName, handler) {
    const boundHandler = handler.bind(this);
    emitter.on(eventName, boundHandler);
    this.activeListeners.push({ emitter, eventName, boundHandler });
  }
  cleanupListeners() {
    this.activeListeners.forEach(({ emitter, eventName, boundHandler }) => {
      emitter.off(eventName, boundHandler);
    });
    this.activeListeners = [];
  }
  /**
   * Inits browser listeners and sets initial handlers for given pages.
   * Function is also intended to be used while reloading DevTools session.
   * @param browser Puppeteer Browser
   * @param pages Puppeteer page array
   */
  initBrowser(browser, pages) {
    this.cleanupListeners();
    this.elementStore = new ElementStore();
    this.windows = /* @__PURE__ */ new Map();
    this.activeDialog = void 0;
    this.browser = browser;
    this.addListener(this.browser, "targetcreated", this._targetCreatedHandler);
    this.addListener(this.browser, "targetdestroyed", this._targetDestroyedHandler);
    for (const page2 of pages) {
      this._createWindowHandle(page2);
    }
    this.setTimeouts(DEFAULT_IMPLICIT_TIMEOUT, DEFAULT_PAGELOAD_TIMEOUT, DEFAULT_SCRIPT_TIMEOUT);
    const page = this.getPageHandle();
    if (page) {
      this.addListener(page, "dialog", this.dialogHandler);
      this.addListener(page, "framenavigated", this.framenavigatedHandler);
    }
  }
  register(commandInfo) {
    const self = this;
    const { command, ref, parameters, variables = [] } = commandInfo;
    if (typeof this.commands[command] !== "function") {
      return () => {
        throw new Error(
          `Command "${command}" is not supported using the Devtools protocol. You might want to use WebDriver as automation engine. For more information check out https://webdriver.io/docs/automationProtocols!`
        );
      };
    }
    let retries = 0;
    const wrappedCommand = async function(...args2) {
      await self.checkPendingNavigations();
      const params = validate(command, parameters, variables, ref, args2);
      let result2;
      try {
        this.emit("command", { command, params, retries });
        result2 = await self.commands[command].call(self, params);
      } catch (err) {
        if (err.message.includes("most likely because of a navigation")) {
          log3.debug("Command failed due to unfinished page transition, retrying...");
          const page = self.getPageHandle();
          ++retries;
          if (retries >= 3) {
            await new Promise((resolve3, reject) => {
              const pageloadTimeout = setTimeout(() => reject(new Error("page load timeout")), self.timeouts.get("pageLoad"));
              page.once("load", () => {
                clearTimeout(pageloadTimeout);
                resolve3();
              });
            });
          }
          return wrappedCommand.apply(this, args2);
        }
        throw sanitizeError(err);
      }
      this.emit("result", { command, params, retries, result: { value: result2 } });
      if (typeof result2 !== "undefined") {
        const isScreenshot = command.toLowerCase().includes("screenshot") && typeof result2 === "string" && result2.length > 64;
        log3.info("RESULT", isScreenshot ? `${result2.substr(0, 61)}...` : result2);
      }
      return result2;
    };
    return wrappedCommand;
  }
  dialogHandler(dialog) {
    this.activeDialog = dialog;
  }
  framenavigatedHandler(frame) {
    this.currentFrameUrl = frame.url();
    this.elementStore.clear(frame.parentFrame() ? frame : void 0);
  }
  setTimeouts(implicit, pageLoad, script2) {
    if (typeof implicit === "number") {
      this.timeouts.set("implicit", implicit);
    }
    if (typeof pageLoad === "number") {
      this.timeouts.set("pageLoad", pageLoad);
    }
    if (typeof script2 === "number") {
      this.timeouts.set("script", script2);
    }
    const page = this.getPageHandle();
    const pageloadTimeout = this.timeouts.get("pageLoad");
    if (page && pageloadTimeout) {
      page.setDefaultTimeout(pageloadTimeout);
    }
  }
  getPageHandle(isInFrame = false) {
    if (isInFrame && this.currentFrame) {
      return this.currentFrame;
    }
    if (!this.currentWindowHandle) {
      throw new Error("no current window handle registered");
    }
    const pageHandle = this.windows.get(this.currentWindowHandle);
    if (!pageHandle) {
      throw new Error("Couldn't find page handle");
    }
    return pageHandle;
  }
  async checkPendingNavigations(pendingNavigationStart = Date.now()) {
    let page = this.getPageHandle();
    if (this.activeDialog || !page) {
      return;
    }
    if (!page.mainFrame) {
      const pages = await this.browser.pages();
      const mainFrame = pages.find((browserPage) => browserPage.frames().find((frame) => page === frame));
      if (mainFrame) {
        page = mainFrame;
      }
    }
    const pageloadTimeout = this.timeouts.get("pageLoad");
    const pageloadTimeoutReached = typeof pageloadTimeout !== "undefined" ? Date.now() - pendingNavigationStart > pageloadTimeout : false;
    try {
      const executionContext = await page.mainFrame();
      await executionContext.evaluate("1");
      const readyState = await executionContext.evaluate("document.readyState");
      if (readyState === "complete" || pageloadTimeoutReached) {
        return;
      }
    } catch (err) {
      if (pageloadTimeoutReached) {
        throw err;
      }
    }
    await new Promise((resolve3) => setTimeout(resolve3, Math.min(100, typeof pageloadTimeout === "number" ? pageloadTimeout / 10 : 100)));
    await this.checkPendingNavigations(pendingNavigationStart);
  }
};

// src/index.ts
var log4 = logger4("devtools:puppeteer");
var sessionMap = /* @__PURE__ */ new Map();
var isDebugPatched = false;
async function patchDebugPkg() {
  if (!isDebugPatched) {
    await patchDebug(log4);
    isDebugPatched = true;
  }
}
var DevTools = class {
  static async newSession(options, modifier, userPrototype = {}, customCommandWrapper) {
    await patchDebugPkg();
    const envLogLevel = process.env.WDIO_LOG_LEVEL;
    options.logLevel = envLogLevel ?? options.logLevel;
    const params = validateConfig(DEFAULTS, options);
    if (params.logLevel && (!options.logLevels || !options.logLevels.devtools)) {
      logger4.setLevel("devtools", params.logLevel);
    }
    if (params.outputDir && !process.env.WDIO_LOG_PATH) {
      process.env.WDIO_LOG_PATH = path6.join(params.outputDir, "wdio.log");
    }
    log4.info("Initiate new session using the DevTools protocol");
    const requestedCapabilities = { ...params.capabilities };
    const browser = await launch(params.capabilities);
    const pages = await browser.pages();
    const driver = new DevToolsDriver(browser, pages);
    const sessionId = uuidv44();
    const uaParser = new UAParser(await browser.userAgent());
    const userAgent = uaParser.getResult();
    const availableVendorPrefixes = Object.values(VENDOR_PREFIX);
    const vendorCapPrefix = Object.keys(params.capabilities).find(
      (capKey) => availableVendorPrefixes.includes(capKey)
    ) || VENDOR_PREFIX[userAgent.browser.name?.toLocaleLowerCase()];
    const { browserName } = requestedCapabilities.alwaysMatch || requestedCapabilities;
    params.capabilities = {
      browserName: (userAgent.browser.name || browserName || "unknown").split(" ").shift()?.toLowerCase(),
      browserVersion: userAgent.browser.version,
      platformName: os4.platform()
      // platform: os.release()
    };
    if (vendorCapPrefix) {
      Object.assign(params.capabilities, {
        [vendorCapPrefix]: Object.assign(
          { debuggerAddress: browser.wsEndpoint().split("/")[2] },
          params.capabilities[vendorCapPrefix]
        )
      });
    }
    sessionMap.set(sessionId, { browser, session: driver });
    const environmentPrototype = {};
    Object.entries(devtoolsEnvironmentDetector({
      browserName: userAgent?.browser?.name?.toLowerCase()
    })).forEach(([name, value]) => {
      environmentPrototype[name] = { value };
    });
    const commandWrapper = (method, endpoint, commandInfo) => driver.register(commandInfo);
    const protocolCommands = getPrototype(commandWrapper);
    const prototype = {
      ...protocolCommands,
      ...userPrototype,
      ...environmentPrototype
    };
    const monad = webdriverMonad(
      { ...params, requestedCapabilities },
      modifier,
      prototype
    );
    return monad(sessionId, customCommandWrapper);
  }
  /**
   * Changes The instance session id and browser capabilities for the new session
   * directly into the passed in browser object
   *
   * @param   {object} instance  the object we get from a new browser session.
   * @returns {string}           the new session id of the browser
   */
  static async reloadSession(instance, newCapabilities) {
    await patchDebugPkg();
    const { session } = sessionMap.get(instance.sessionId);
    const browser = await launch({
      ...instance.requestedCapabilities,
      ...newCapabilities || {}
    });
    const pages = await browser.pages();
    session.initBrowser.call(session, browser, pages);
    instance.puppeteer = browser;
    sessionMap.set(instance.sessionId, { browser, session });
    return instance.sessionId;
  }
  /**
   * allows user to attach to existing sessions
   */
  static async attachToSession(options, modifier, userPrototype = {}, customCommandWrapper) {
    await patchDebugPkg();
    const browser = await launch(options.capabilities);
    const pages = await browser.pages();
    const driver = new DevToolsDriver(browser, pages);
    const sessionId = uuidv44();
    const uaParser = new UAParser(await browser.userAgent());
    const userAgent = uaParser.getResult();
    const environmentPrototype = { puppeteer: { value: browser, writable: true } };
    Object.entries(devtoolsEnvironmentDetector({
      browserName: userAgent?.browser?.name?.toLowerCase()
    })).forEach(([name, value]) => {
      environmentPrototype[name] = { value };
    });
    const commandWrapper = (method, endpoint, commandInfo) => driver.register(commandInfo);
    const protocolCommands = getPrototype(commandWrapper);
    const prototype = {
      ...protocolCommands,
      ...userPrototype,
      ...environmentPrototype
    };
    const monad = webdriverMonad(
      options,
      modifier,
      prototype
    );
    return monad(sessionId, customCommandWrapper);
  }
};
export {
  SUPPORTED_BROWSER,
  DevTools as default,
  sessionMap
};
/**
 * @license Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
