const __importMetaUrl = require('url').pathToFileURL(__filename).href;
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/node/index.ts
var index_exports = {};
__export(index_exports, {
  canAccess: () => canAccess,
  setupBrowser: () => setupBrowser,
  setupDriver: () => setupDriver,
  startWebDriver: () => startWebDriver
});
module.exports = __toCommonJS(index_exports);

// src/node/startWebDriver.ts
var import_node_fs2 = __toESM(require("node:fs"), 1);
var import_node_path3 = __toESM(require("node:path"), 1);
var import_node_child_process2 = __toESM(require("node:child_process"), 1);
var import_get_port = __toESM(require("get-port"), 1);
var import_wait_port = __toESM(require("wait-port"), 1);

// src/logger.ts
var import_wdio_logger = __toESM(require("@testplane/wdio-logger"), 1);
var safeESModule = (a) => {
  const b = a;
  return b.__esModule || b[Symbol.toStringTag] === "Module" ? b.default : b;
};
var logger_default = safeESModule(import_wdio_logger.default);

// src/node/startWebDriver.ts
var import_split2 = __toESM(require("split2"), 1);
var import_deepmerge_ts = require("deepmerge-ts");
var import_safaridriver = require("safaridriver");
var import_geckodriver2 = require("@testplane/geckodriver");
var import_edgedriver2 = require("@testplane/edgedriver");

// src/node/utils.ts
var import_node_os = __toESM(require("node:os"), 1);
var import_node_fs = __toESM(require("node:fs"), 1);
var import_promises = __toESM(require("node:fs/promises"), 1);
var import_node_path = __toESM(require("node:path"), 1);
var import_node_child_process = __toESM(require("node:child_process"), 1);
var import_decamelize = __toESM(require("decamelize"), 1);
var import_browsers = require("@puppeteer/browsers");
var import_geckodriver = require("@testplane/geckodriver");
var import_edgedriver = require("@testplane/edgedriver");
var import_locate_app = require("locate-app");
var log = logger_default("webdriver");
var EXCLUDED_PARAMS = ["version", "help"];
var canAccess = (file) => {
  if (!file) {
    return false;
  }
  try {
    import_node_fs.default.accessSync(file);
    return true;
  } catch {
    return false;
  }
};
function parseParams(params) {
  return Object.entries(params).filter(([key]) => !EXCLUDED_PARAMS.includes(key)).map(([key, val]) => {
    if (typeof val === "boolean" && !val) {
      return "";
    }
    const vals = Array.isArray(val) ? val : [val];
    return vals.map((v) => `--${(0, import_decamelize.default)(key, { separator: "-" })}${typeof v === "boolean" ? "" : `=${v}`}`);
  }).flat().filter(Boolean);
}
function getBuildIdByChromePath(chromePath) {
  if (!chromePath) {
    return;
  }
  if (import_node_os.default.platform() === "win32") {
    const versionPath = import_node_path.default.dirname(chromePath);
    const contents = import_node_fs.default.readdirSync(versionPath);
    const versions = contents.filter((a) => /^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/g.test(a));
    const oldest = versions.sort((a, b) => a > b ? -1 : 1)[0];
    return oldest;
  }
  const versionString = import_node_child_process.default.execSync(`"${chromePath}" --version --no-sandbox`).toString();
  const versionSanitized = versionString.trim().split(" ").find((s) => s.split(".").length === 4);
  if (!versionSanitized) {
    throw new Error(`Couldn't find valid Chrome version from "${versionString}", please raise an issue in the WebdriverIO project (https://github.com/webdriverio/webdriverio/issues/new/choose)`);
  }
  return versionSanitized;
}
async function getBuildIdByFirefoxPath(firefoxPath) {
  if (!firefoxPath) {
    return;
  }
  if (import_node_os.default.platform() === "win32") {
    const appPath = import_node_path.default.dirname(firefoxPath);
    const contents = (await import_promises.default.readFile(import_node_path.default.join(appPath, "application.ini"))).toString("utf-8");
    return contents.split("\n").filter((line) => line.startsWith("Version=")).map((line) => line.replace("Version=", "").replace(/\r/, "")).pop();
  }
  const versionString = import_node_child_process.default.execSync(`"${firefoxPath}" --version`).toString();
  return versionString.trim().split(" ").pop()?.trim();
}
var lastTimeCalled = Date.now();
var downloadProgressCallback = (artifact, downloadedBytes, totalBytes) => {
  if (Date.now() - lastTimeCalled < 1e3) {
    return;
  }
  const percentage = (downloadedBytes / totalBytes * 100).toFixed(2);
  log.progress(`Downloading ${artifact} ${percentage}%`);
  lastTimeCalled = Date.now();
};
var _install = async (args, retry = false) => {
  await (0, import_browsers.install)(args).catch((err) => {
    const error = `Failed downloading ${args.browser} v${args.buildId} using ${JSON.stringify(args)}: ${err.message}, retrying ...`;
    if (retry) {
      err.message += "\n" + error.replace(", retrying ...", "");
      throw new Error(err);
    }
    log.error(error);
    return _install(args, true);
  });
  log.progress("");
};
function locateChromeSafely() {
  return (0, import_locate_app.locateChrome)().catch(() => void 0);
}
async function setupPuppeteerBrowser(cacheDir, caps) {
  caps.browserName = caps.browserName?.toLowerCase();
  const browserName = caps.browserName === import_browsers.Browser.FIREFOX ? import_browsers.Browser.FIREFOX : caps.browserName === import_browsers.Browser.CHROMIUM ? import_browsers.Browser.CHROMIUM : import_browsers.Browser.CHROME;
  const exist = await import_promises.default.access(cacheDir).then(() => true, () => false);
  const isChromeOrChromium = browserName === import_browsers.Browser.CHROME || caps.browserName === import_browsers.Browser.CHROMIUM;
  if (!exist) {
    await import_promises.default.mkdir(cacheDir, { recursive: true });
  }
  if (browserName === import_browsers.Browser.CHROMIUM) {
    caps.browserName = import_browsers.Browser.CHROME;
  }
  const browserOptions = (isChromeOrChromium ? caps["goog:chromeOptions"] : caps["moz:firefoxOptions"]) || {};
  if (typeof browserOptions.binary === "string") {
    return {
      executablePath: browserOptions.binary,
      browserVersion: caps.browserVersion || (isChromeOrChromium ? getBuildIdByChromePath(browserOptions.binary) : await getBuildIdByFirefoxPath(browserOptions.binary))
    };
  }
  const platform = (0, import_browsers.detectBrowserPlatform)();
  if (!platform) {
    throw new Error("The current platform is not supported.");
  }
  if (!caps.browserVersion) {
    const executablePath2 = browserName === import_browsers.Browser.CHROME ? await locateChromeSafely() : browserName === import_browsers.Browser.CHROMIUM ? await (0, import_locate_app.locateApp)({
      appName: import_browsers.Browser.CHROMIUM,
      macOsName: import_browsers.Browser.CHROMIUM,
      linuxWhich: "chromium-browser"
    }).catch(() => void 0) : await (0, import_locate_app.locateFirefox)().catch(() => void 0);
    const browserVersion2 = isChromeOrChromium ? getBuildIdByChromePath(executablePath2) : await getBuildIdByFirefoxPath(executablePath2);
    if (browserVersion2) {
      return {
        executablePath: executablePath2,
        browserVersion: browserVersion2
      };
    }
  }
  const tag = browserName === import_browsers.Browser.CHROME ? caps.browserVersion || import_browsers.ChromeReleaseChannel.STABLE : caps.browserVersion || "latest";
  const buildId = await (0, import_browsers.resolveBuildId)(browserName, platform, tag);
  const installOptions = {
    unpack: true,
    cacheDir,
    platform,
    buildId,
    browser: browserName,
    downloadProgressCallback: (downloadedBytes, totalBytes) => downloadProgressCallback(`${browserName} (${buildId})`, downloadedBytes, totalBytes)
  };
  const isCombinationAvailable = await (0, import_browsers.canDownload)(installOptions);
  if (!isCombinationAvailable) {
    throw new Error(`Couldn't find a matching ${browserName} browser for tag "${buildId}" on platform "${platform}"`);
  }
  log.info(`Setting up ${browserName} v${buildId}`);
  await _install(installOptions);
  const executablePath = (0, import_browsers.computeExecutablePath)(installOptions);
  let browserVersion = buildId;
  if (browserName === import_browsers.Browser.CHROMIUM) {
    browserVersion = await (0, import_browsers.resolveBuildId)(import_browsers.Browser.CHROME, platform, tag);
  }
  return { executablePath, browserVersion };
}
function getDriverOptions(caps) {
  return caps["wdio:chromedriverOptions"] || caps["wdio:geckodriverOptions"] || caps["wdio:edgedriverOptions"] || // Safaridriver does not have any options as it already
  // is installed on macOS
  {};
}
function getCacheDir(options, caps) {
  const driverOptions = getDriverOptions(caps);
  return driverOptions.cacheDir || options.cacheDir || import_node_os.default.tmpdir();
}
function getMajorVersionFromString(fullVersion) {
  let prefix;
  if (fullVersion) {
    prefix = fullVersion.match(/^[+-]?([0-9]+)/);
  }
  return prefix && prefix.length > 0 ? prefix[0] : "";
}
async function setupChromedriver(cacheDir, driverVersion) {
  const platform = (0, import_browsers.detectBrowserPlatform)();
  if (!platform) {
    throw new Error("The current platform is not supported.");
  }
  const version = driverVersion || getBuildIdByChromePath(await locateChromeSafely()) || import_browsers.ChromeReleaseChannel.STABLE;
  const buildId = await (0, import_browsers.resolveBuildId)(import_browsers.Browser.CHROMEDRIVER, platform, version);
  let executablePath = (0, import_browsers.computeExecutablePath)({
    browser: import_browsers.Browser.CHROMEDRIVER,
    buildId,
    platform,
    cacheDir
  });
  const hasChromedriverInstalled = await import_promises.default.access(executablePath).then(() => true, () => false);
  if (!hasChromedriverInstalled) {
    log.info(`Downloading Chromedriver v${buildId}`);
    const chromedriverInstallOpts = {
      cacheDir,
      buildId,
      platform,
      browser: import_browsers.Browser.CHROMEDRIVER,
      unpack: true,
      downloadProgressCallback: (downloadedBytes, totalBytes) => downloadProgressCallback("Chromedriver", downloadedBytes, totalBytes)
    };
    let knownBuild = buildId;
    if (await (0, import_browsers.canDownload)(chromedriverInstallOpts)) {
      await _install({ ...chromedriverInstallOpts, buildId });
      log.info(`Download of Chromedriver v${buildId} was successful`);
    } else {
      log.warn(`Chromedriver v${buildId} don't exist, trying to find known good version...`);
      knownBuild = await (0, import_browsers.resolveBuildId)(import_browsers.Browser.CHROMEDRIVER, platform, getMajorVersionFromString(version));
      if (knownBuild) {
        await _install({ ...chromedriverInstallOpts, buildId: knownBuild });
        log.info(`Download of Chromedriver v${knownBuild} was successful`);
      } else {
        throw new Error(`Couldn't download any known good version from Chromedriver major v${getMajorVersionFromString(version)}, requested full version - v${version}`);
      }
    }
    executablePath = (0, import_browsers.computeExecutablePath)({
      browser: import_browsers.Browser.CHROMEDRIVER,
      buildId: knownBuild,
      platform,
      cacheDir
    });
  } else {
    log.info(`Using Chromedriver v${buildId} from cache directory ${cacheDir}`);
  }
  return { executablePath };
}
function setupGeckodriver(cacheDir, driverVersion) {
  return (0, import_geckodriver.download)(driverVersion, cacheDir);
}
function setupEdgedriver(cacheDir, driverVersion) {
  return (0, import_edgedriver.download)(driverVersion, cacheDir);
}

// src/utils.ts
var import_promises2 = __toESM(require("node:fs/promises"), 1);
var import_node_url = __toESM(require("node:url"), 1);
var import_node_path2 = __toESM(require("node:path"), 1);

// src/constants.ts
var SUPPORTED_BROWSERNAMES = {
  chrome: ["chrome", "googlechrome", "chromium", "chromium-browser"],
  firefox: ["firefox", "ff", "mozilla", "mozilla firefox"],
  edge: ["edge", "microsoftedge", "msedge"],
  safari: ["safari", "safari technology preview"]
};
var DEFAULT_HOSTNAME = "localhost";
var DEFAULT_PROTOCOL = "http";
var DEFAULT_PATH = "/";

// src/utils.ts
function isAppiumCapability(caps) {
  return Boolean(
    caps && // @ts-expect-error outdated jsonwp cap
    (caps.automationName || caps["appium:automationName"] || "appium:options" in caps && caps["appium:options"]?.automationName || // @ts-expect-error outdated jsonwp cap
    caps.deviceName || caps["appium:deviceName"] || "appium:options" in caps && caps["appium:options"]?.deviceName || "lt:options" in caps && caps["lt:options"]?.deviceName || caps.appiumVersion || caps["appium:appiumVersion"] || "appium:options" in caps && caps["appium:options"]?.appiumVersion || "lt:options" in caps && caps["lt:options"]?.appiumVersion)
  );
}
function definesRemoteDriver(options) {
  return Boolean(
    options.protocol && options.protocol !== DEFAULT_PROTOCOL || options.hostname && options.hostname !== DEFAULT_HOSTNAME || Boolean(options.port) || options.path && options.path !== DEFAULT_PATH || Boolean(options.user && options.key)
  );
}
function isChrome(browserName) {
  return Boolean(browserName && SUPPORTED_BROWSERNAMES.chrome.includes(browserName.toLowerCase()));
}
function isSafari(browserName) {
  return Boolean(browserName && SUPPORTED_BROWSERNAMES.safari.includes(browserName.toLowerCase()));
}
function isFirefox(browserName) {
  return Boolean(browserName && SUPPORTED_BROWSERNAMES.firefox.includes(browserName.toLowerCase()));
}
function isEdge(browserName) {
  return Boolean(browserName && SUPPORTED_BROWSERNAMES.edge.includes(browserName.toLowerCase()));
}

// src/node/startWebDriver.ts
var log2 = logger_default("@testplane/wdio-utils");
var DRIVER_WAIT_TIMEOUT = 10 * 1e3;
async function startWebDriver(options) {
  if (process.env.WDIO_SKIP_DRIVER_SETUP) {
    options.hostname = "localhost";
    options.port = 4321;
    return;
  }
  let driverProcess;
  let driver = "";
  const start = Date.now();
  const caps = options.capabilities.alwaysMatch || options.capabilities;
  if (isAppiumCapability(caps)) {
    return;
  }
  if (!caps.browserName) {
    throw new Error(
      `No "browserName" defined in capabilities nor hostname or port found!
If you like to run a local browser session make sure to pick from one of the following browser names: ${Object.values(SUPPORTED_BROWSERNAMES).flat(Infinity)}`
    );
  }
  const port = await (0, import_get_port.default)();
  const cacheDir = getCacheDir(options, caps);
  if (isChrome(caps.browserName)) {
    const chromedriverOptions = caps["wdio:chromedriverOptions"] || {};
    const chromedriverBinary = chromedriverOptions.binary || process.env.CHROMEDRIVER_PATH;
    const { executablePath: chromeExecuteablePath, browserVersion } = await setupPuppeteerBrowser(cacheDir, caps);
    const { executablePath: chromedriverExcecuteablePath } = chromedriverBinary ? { executablePath: chromedriverBinary } : await setupChromedriver(cacheDir, browserVersion);
    caps["goog:chromeOptions"] = (0, import_deepmerge_ts.deepmerge)(
      { binary: chromeExecuteablePath },
      caps["goog:chromeOptions"] || {}
    );
    chromedriverOptions.allowedOrigins = chromedriverOptions.allowedOrigins || ["*"];
    chromedriverOptions.allowedIps = chromedriverOptions.allowedIps || ["0.0.0.0"];
    const driverParams = parseParams({ port, ...chromedriverOptions });
    driverProcess = import_node_child_process2.default.spawn(chromedriverExcecuteablePath, driverParams, {
      env: { ...process.env, NODE_OPTIONS: "" },
      ...chromedriverOptions.spawnOpts || {}
    });
    driver = `Chromedriver v${browserVersion} with params ${driverParams.join(" ")}`;
  } else if (isSafari(caps.browserName)) {
    const safaridriverOptions = caps["wdio:safaridriverOptions"] || {};
    driver = "SafariDriver";
    driverProcess = (0, import_safaridriver.start)({
      useTechnologyPreview: /preview/i.test(caps.browserName),
      ...safaridriverOptions,
      port
    });
  } else if (isFirefox(caps.browserName)) {
    const { executablePath } = await setupPuppeteerBrowser(cacheDir, caps);
    caps["moz:firefoxOptions"] = (0, import_deepmerge_ts.deepmerge)(
      { binary: executablePath },
      caps["moz:firefoxOptions"] || {}
    );
    delete caps.browserVersion;
    const { binary, ...geckodriverOptions } = caps["wdio:geckodriverOptions"] || {};
    if (binary) {
      geckodriverOptions.customGeckoDriverPath = binary;
    }
    driver = "GeckoDriver";
    driverProcess = await (0, import_geckodriver2.start)({ ...geckodriverOptions, cacheDir, port, allowHosts: ["localhost"] });
  } else if (isEdge(caps.browserName)) {
    const { binary, ...edgedriverOptions } = caps["wdio:edgedriverOptions"] || {};
    if (binary) {
      edgedriverOptions.customEdgeDriverPath = binary;
    }
    driver = "EdgeDriver";
    driverProcess = await (0, import_edgedriver2.start)({ ...edgedriverOptions, cacheDir, port, allowedIps: ["0.0.0.0"] }).catch((err) => {
      log2.warn(`Couldn't start EdgeDriver: ${err.message}, retry ...`);
      return (0, import_edgedriver2.start)({ ...edgedriverOptions, cacheDir, port });
    });
    caps.browserName = "MicrosoftEdge";
    if (!caps["ms:edgeOptions"]?.binary) {
      caps["ms:edgeOptions"] = caps["ms:edgeOptions"] || {};
      caps["ms:edgeOptions"].binary = (0, import_edgedriver2.findEdgePath)();
      log2.info(`Found Edge binary at ${caps["ms:edgeOptions"].binary}`);
    }
  } else {
    throw new Error(
      `Unknown browser name "${caps.browserName}". Make sure to pick from one of the following ` + Object.values(SUPPORTED_BROWSERNAMES).flat(Infinity)
    );
  }
  const logIdentifier = driver.split(" ").shift()?.toLowerCase() || "driver";
  if (options.outputDir) {
    const logFileName = process.env.WDIO_WORKER_ID ? `wdio-${process.env.WDIO_WORKER_ID}-${logIdentifier}.log` : `wdio-${logIdentifier}-${port}.log`;
    const logFile = import_node_path3.default.resolve(options.outputDir, logFileName);
    const logStream = import_node_fs2.default.createWriteStream(logFile, { flags: "w" });
    driverProcess.stdout?.pipe(logStream);
    driverProcess.stderr?.pipe(logStream);
  } else {
    const driverLog = logger_default(logIdentifier);
    driverProcess.stdout?.pipe((0, import_split2.default)()).on("data", driverLog.info.bind(driverLog));
    driverProcess.stderr?.pipe((0, import_split2.default)()).on("data", driverLog.warn.bind(driverLog));
  }
  await (0, import_wait_port.default)({ port, output: "silent", timeout: DRIVER_WAIT_TIMEOUT }).catch((e) => {
    throw new Error(`Timed out to connect to ${driver}: ${e.message}`);
  });
  options.hostname = "localhost";
  options.port = port;
  log2.info(`Started ${driver} in ${Date.now() - start}ms on port ${port}`);
  return driverProcess;
}

// src/node/manager.ts
var log3 = logger_default("@testplane/wdio-utils");
var UNDEFINED_BROWSER_VERSION = null;
var firefoxChannels = ["stable", "latest"];
function mapCapabilities(options, caps, task, taskItemLabel) {
  const capabilitiesToRequireSetup = (Array.isArray(caps) ? caps.map((cap) => {
    const w3cCaps = cap;
    const multiremoteCaps = cap;
    const multiremoteInstanceNames = Object.keys(multiremoteCaps);
    if (typeof multiremoteCaps[multiremoteInstanceNames[0]] === "object" && "capabilities" in multiremoteCaps[multiremoteInstanceNames[0]]) {
      return Object.values(multiremoteCaps).map((c) => {
        if (c.automationProtocol === "devtools") {
          return;
        }
        return "alwaysMatch" in c.capabilities ? c.capabilities.alwaysMatch : c.capabilities;
      });
    }
    if (w3cCaps.alwaysMatch) {
      return w3cCaps.alwaysMatch;
    }
    return cap;
  }).flat() : Object.values(caps).map((mrOpts) => {
    const w3cCaps = mrOpts.capabilities;
    if (mrOpts.automationProtocol === "devtools") {
      return;
    }
    if (w3cCaps.alwaysMatch) {
      return w3cCaps.alwaysMatch;
    }
    return mrOpts.capabilities;
  })).flat().filter((cap) => (
    /**
     * only set up driver if
     */
    // - capabilities are defined and not empty because automationProtocol is set to `devtools`
    cap && // - browserName is defined so we know it is a browser session
    cap.browserName && // - we are not about to run a cloud session
    !definesRemoteDriver(options) && // - we are not running Safari (driver already installed on macOS)
    !isSafari(cap.browserName) && // - environment does not define a binary path
    !getDriverOptions(cap).binary && // - user is not defining "devtools" as automation protocol
    options.automationProtocol !== "devtools"
  ));
  if (capabilitiesToRequireSetup.length === 0) {
    return;
  }
  const queueByBrowserName = capabilitiesToRequireSetup.reduce((queue, cap) => {
    if (!cap.browserName) {
      return queue;
    }
    if (!queue.has(cap.browserName)) {
      queue.set(cap.browserName, /* @__PURE__ */ new Map());
    }
    const browserVersion = cap.browserVersion || UNDEFINED_BROWSER_VERSION;
    queue.get(cap.browserName).set(browserVersion, cap);
    return queue;
  }, /* @__PURE__ */ new Map());
  const driverToSetupString = Array.from(queueByBrowserName.entries()).map(([browserName, versions]) => `${browserName}@${Array.from(versions.keys()).map((bv) => bv || "stable").join(", ")}`).join(" - ");
  log3.info(`Setting up ${taskItemLabel} for: ${driverToSetupString}`);
  return Promise.all(
    Array.from(queueByBrowserName.entries()).map(([browserName, queueByBrowserVersion]) => {
      return Array.from(queueByBrowserVersion).map(([browserVersion, cap]) => task({
        ...cap,
        browserName,
        ...browserVersion !== UNDEFINED_BROWSER_VERSION ? { browserVersion } : {}
      }));
    }).flat()
  );
}
async function setupDriver(options, caps) {
  return mapCapabilities(options, caps, async (cap) => {
    const cacheDir = getCacheDir(options, cap);
    if (isEdge(cap.browserName)) {
      return setupEdgedriver(cacheDir, cap.browserVersion);
    } else if (isFirefox(cap.browserName)) {
      const version = firefoxChannels.includes(cap.browserVersion ?? "") ? void 0 : cap.browserVersion;
      return setupGeckodriver(cacheDir, version);
    } else if (isChrome(cap.browserName)) {
      return setupChromedriver(cacheDir, cap.browserVersion);
    }
    return Promise.resolve();
  }, "browser driver" /* DRIVER */);
}
function setupBrowser(options, caps) {
  return mapCapabilities(options, caps, async (cap) => {
    const cacheDir = getCacheDir(options, cap);
    if (isEdge(cap.browserName)) {
      return Promise.resolve();
    } else if (isChrome(cap.browserName) || isFirefox(cap.browserName)) {
      return setupPuppeteerBrowser(cacheDir, cap);
    }
    return Promise.resolve();
  }, "browser binaries" /* BROWSER */);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  canAccess,
  setupBrowser,
  setupDriver,
  startWebDriver
});
