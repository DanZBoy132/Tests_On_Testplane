"use strict";
/*
    Portions of this functionality are copyright of their respective authors
    and released under the MIT license:
    https://github.com/testing-library/webdriverio-testing-library
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.within = within;
exports.setupBrowser = setupBrowser;
exports.configure = configure;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const dom_1 = require("@testing-library/dom");
const DOM_TESTING_LIBRARY_UMD_PATH = path_1.default.join(require.resolve("@testing-library/dom"), "../../", "dist/@testing-library/dom.umd.js");
const DOM_TESTING_LIBRARY_UMD = fs_1.default
    .readFileSync(DOM_TESTING_LIBRARY_UMD_PATH)
    .toString()
    .replace("define.amd", "false")
    // exports and module are defined in component tests. Without this patch, testing-library won't init
    .replace("typeof exports === 'object' && typeof module !== 'undefined'", "false");
let _config;
function isContainerWithExecute(container) {
    return container.execute !== null;
}
function findContainerWithExecute(container) {
    let curContainer = container.parent;
    while (!isContainerWithExecute(curContainer)) {
        curContainer = curContainer.parent;
    }
    return curContainer;
}
const findBrowser = (container) => {
    let browser = container;
    while (browser.parent && browser.capabilities === undefined) {
        browser = browser.parent;
    }
    return browser;
};
async function injectDOMTestingLibrary(container) {
    const browser = findContainerWithExecute(container);
    const shouldInjectDTL = await browser.execute(function () {
        return !window.TestingLibraryDom;
    });
    if (shouldInjectDTL) {
        await browser.execute(function (library) {
            if (navigator.userAgent.indexOf("Firefox") !== -1) {
                try {
                    // Inject via inline-script
                    const script = window.document.createElement("script");
                    script.textContent = library;
                    window.document.head.append(script);
                    if (!window.TestingLibraryDom) {
                        // Inject via eval
                        window.eval(library);
                    }
                }
                catch (error) {
                    throw new Error(`The DOM Testing Library cannot be injected on certain domains, particularly "${window.location.host}", due to restrictions imposed by the Content-Security-Policy (CSP) header. ${error}`);
                }
            }
            else {
                window.eval(library);
            }
        }, DOM_TESTING_LIBRARY_UMD);
    }
    await browser.execute(function (config) {
        window.TestingLibraryDom.configure(config);
    }, _config);
}
function serializeObject(object) {
    return Object.entries(object)
        .map(([key, value]) => [key, serializeArg(value)])
        .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {
        serialized: "object",
    });
}
function serializeArg(arg) {
    if (arg instanceof RegExp) {
        return { serialized: "RegExp", RegExp: arg.toString() };
    }
    if (typeof arg === "undefined") {
        return { serialized: "Undefined", Undefined: true };
    }
    if (arg && typeof arg === "object") {
        return serializeObject(arg);
    }
    return arg;
}
async function executeQuery(query, container, ...args) {
    return new Promise((done) => {
        function deserializeObject(object) {
            return Object.entries(object)
                .map(([key, value]) => [key, deserializeArg(value)])
                .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});
        }
        function deserializeArg(arg) {
            if (typeof arg === "object" && arg === null) {
                return undefined;
            }
            if (typeof arg === "object" && arg.nodeType !== undefined) {
                return arg;
            }
            if (typeof arg === "object" && arg.serialized === "RegExp") {
                return eval(arg.RegExp);
            }
            if (typeof arg === "object" && arg.serialized === "Undefined") {
                return undefined;
            }
            if (typeof arg === "object") {
                return deserializeObject(arg);
            }
            return arg;
        }
        const [matcher, options, waitForOptions] = args.map(deserializeArg);
        void (async () => {
            let result = null;
            try {
                // Override RegExp to fix 'matcher instanceof RegExp' check on Firefox
                window.RegExp = RegExp;
                result = await window.TestingLibraryDom[query](container, 
                // @ts-expect-error Matcher can be any type from @testing-library/dom
                matcher, options, waitForOptions);
            }
            catch (e) {
                return done(e.message);
            }
            if (!result) {
                return done(null);
            }
            function makeSelectorResult(element) {
                const elementIdAttributeName = "data-testplane-element-id";
                let elementId = element.getAttribute(elementIdAttributeName);
                // if id doesn't already exist create one and add it to element
                if (!elementId) {
                    elementId = (Math.abs(Math.random()) * 1000000000000).toFixed(0);
                    element.setAttribute(elementIdAttributeName, elementId);
                }
                return { selector: `[${elementIdAttributeName}="${elementId}"]` };
            }
            if (Array.isArray(result)) {
                return done(result.map(makeSelectorResult));
            }
            return done(makeSelectorResult(result));
        })();
    });
}
function createQuery(container, queryName) {
    return async (...args) => {
        await injectDOMTestingLibrary(container);
        const browser = findBrowser(container);
        const result = await browser.execute(executeQuery, queryName, container, ...args.map(serializeArg));
        if (typeof result === "string") {
            throw new Error(result);
        }
        if (!result) {
            return null;
        }
        if (Array.isArray(result)) {
            return Promise.all(result.map(({ selector }) => container.$(selector)));
        }
        return container.$(result.selector);
    };
}
function within(element) {
    return Object.keys(dom_1.queries).reduce((queries, queryName) => ({
        ...queries,
        [queryName]: createQuery(element, queryName),
    }), {});
}
/*
    eslint-disable
    @typescript-eslint/no-explicit-any
*/
// Patches (via addCommand) the browser object with the DomTestingLibrary queries
function setupBrowser(browser) {
    const queries = {};
    Object.keys(dom_1.queries).forEach(key => {
        const queryName = key;
        const query = async (...args) => {
            const body = await browser.$("body");
            return within(body)[queryName](...args);
        };
        // add query to response queries
        queries[queryName] = query;
        // add query to BrowserObject and Elements
        browser.addCommand(queryName, query);
        browser.addCommand(queryName, function (...args) {
            return within(this)[queryName](...args);
        }, true);
        // add chainable query to BrowserObject and Elements
        browser.addCommand(`${queryName}$`, query);
        browser.addCommand(`${queryName}$`, function (...args) {
            return within(this)[queryName](...args);
        }, true);
    });
    return queries;
}
/*
    eslint-enable
    @typescript-eslint/no-explicit-any
*/
function configure(config) {
    _config = config;
}
__exportStar(require("./types.js"), exports);
