"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatTrackedTests = exports.getTestsByWorkerPid = exports.TestsTracker = void 0;
const strftime_1 = __importDefault(require("strftime"));
const events_1 = require("../events");
function getTestKey(fullTitle, browserId) {
    return `${fullTitle}:${browserId}`;
}
class TestsTracker {
    constructor(emitter) {
        this._tests = new Map();
        emitter.on(events_1.MasterEvents.TEST_BEGIN, (test) => {
            try {
                const key = getTestKey(test.fullTitle(), test.browserId);
                const sessionId = test.sessionId;
                const testInfo = {
                    fullTitle: test.fullTitle(),
                    browserId: test.browserId,
                    file: test.file || "",
                    sessionId,
                    isRunning: true,
                    startTime: Date.now(),
                    retry: 0,
                };
                if (!this._tests.has(key)) {
                    this._tests.set(key, []);
                }
                this._tests.get(key).push(testInfo);
            }
            catch (err) {
                /** */
            }
        });
        emitter.on(events_1.MasterEvents.TEST_ASSIGNED_TO_WORKER, (data) => {
            try {
                const key = getTestKey(data.fullTitle, data.browserId);
                const testInfos = this._tests.get(key);
                if (testInfos && testInfos.length > 0) {
                    const lastTest = testInfos[testInfos.length - 1];
                    lastTest.workerPid = data.workerPid;
                    lastTest.sessionId = data.sessionId;
                }
            }
            catch (err) {
                /** */
            }
        });
        emitter.on(events_1.MasterEvents.TEST_END, (test) => {
            try {
                const key = getTestKey(test.fullTitle(), test.browserId);
                const testInfos = this._tests.get(key);
                if (testInfos && testInfos.length > 0) {
                    const lastTest = testInfos[testInfos.length - 1];
                    lastTest.isRunning = false;
                    const sessionId = test.sessionId;
                    if (sessionId) {
                        lastTest.sessionId = sessionId;
                    }
                }
            }
            catch (err) {
                /** */
            }
        });
    }
    getAllTests() {
        try {
            const allTests = [];
            for (const testInfos of this._tests.values()) {
                testInfos.forEach((testInfo, index) => {
                    allTests.push({
                        ...testInfo,
                        retry: index,
                    });
                });
            }
            return allTests;
        }
        catch (err) {
            return [];
        }
    }
}
exports.TestsTracker = TestsTracker;
function getTestsByWorkerPid(tests, workerPid) {
    try {
        return tests.filter(t => t.workerPid === workerPid).sort((a, b) => b.startTime - a.startTime);
    }
    catch (err) {
        return [];
    }
}
exports.getTestsByWorkerPid = getTestsByWorkerPid;
function formatTrackedTests(tests) {
    try {
        if (tests.length === 0) {
            return "No tests were tracked at the time of the error.";
        }
        const lines = [`These tests were running or recently ran:`];
        for (const { fullTitle, browserId, startTime, workerPid, sessionId, isRunning, file, retry } of tests) {
            const startedAt = (0, strftime_1.default)("started at %H:%M:%S", new Date(startTime));
            const duration = Date.now() - startTime;
            const status = isRunning ? "RUNNING" : "finished";
            const workerInfo = workerPid ? `worker PID: ${workerPid}` : "worker PID: unknown";
            const sessionInfo = sessionId ? `session: ${sessionId}` : "";
            const retryInfo = `retry: ${Number(retry)}`;
            const extraInfo = [status, workerInfo, sessionInfo, retryInfo].filter(Boolean).join(", ");
            lines.push(`  - "${fullTitle}" [${browserId}] (${startedAt}, took ${duration}ms, ${extraInfo})`);
            lines.push(`    File: ${file || "unknown"}`);
        }
        return lines.join("\n");
    }
    catch (err) {
        return "Failed to format tracked tests information.";
    }
}
exports.formatTrackedTests = formatTrackedTests;
//# sourceMappingURL=tests-tracker.js.map