"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHashWriter = exports.HashWriter = void 0;
const lodash_1 = require("lodash");
const node_path_1 = __importDefault(require("node:path"));
const hash_provider_1 = require("./hash-provider");
const utils_1 = require("./utils");
const json_utils_1 = require("./json-utils");
class HashWriter {
    constructor(testDependenciesPath, compression) {
        this._hashProvider = new hash_provider_1.HashProvider();
        // "null" - successfully writed, "Promise<string>" - file/module hash, "Promise<Error>" - calculating hash error
        this._stagedFileHashes = new Map();
        this._stagedModuleHashes = new Map();
        this._stagedPatternHashes = new Map();
        this._selectivityHashesPath = (0, utils_1.getSelectivityHashesPath)(testDependenciesPath);
        this._compresion = compression;
    }
    _addFileDependency(filePath) {
        if (this._stagedFileHashes.has(filePath)) {
            return;
        }
        const value = this._hashProvider.calculateForFile(filePath).catch(err => err);
        this._stagedFileHashes.set(filePath, value);
    }
    _addPatternDependency(pattern) {
        if (this._stagedPatternHashes.has(pattern)) {
            return;
        }
        const value = this._hashProvider.calculateForPattern(pattern).catch(err => err);
        this._stagedPatternHashes.set(pattern, value);
    }
    _addModuleDependency(modulePath) {
        if (this._stagedModuleHashes.has(modulePath)) {
            return;
        }
        const filePath = node_path_1.default.join(modulePath, "package.json");
        const value = this._hashProvider.calculateForFile(filePath).catch(err => err);
        this._stagedModuleHashes.set(modulePath, value);
    }
    addPatternDependencyHash(dependencyPatterns) {
        return this._addPatternDependency(dependencyPatterns);
    }
    addTestDependencyHashes(dependencies) {
        dependencies.css.forEach(dependency => this._addFileDependency(dependency));
        dependencies.js.forEach(dependency => this._addFileDependency(dependency));
        dependencies.modules.forEach(dependency => this._addModuleDependency(dependency));
    }
    async commit() {
        const hasStaged = Boolean(this._stagedFileHashes.size || this._stagedModuleHashes.size || this._stagedPatternHashes.size);
        if (!hasStaged) {
            return;
        }
        const stagedModuleNames = Array.from(this._stagedModuleHashes.keys());
        const stagedFileNames = Array.from(this._stagedFileHashes.keys());
        const stagedPatternNames = Array.from(this._stagedPatternHashes.keys());
        const filterMatchingHashes = async (keys, src, dest) => {
            const remainingKeys = [];
            for (const key of keys) {
                const oldValue = dest[key];
                const newValue = await src.get(key);
                if (newValue === null) {
                    continue;
                }
                if (newValue === oldValue) {
                    src.set(key, null);
                }
                else {
                    remainingKeys.push(key);
                }
            }
            return remainingKeys;
        };
        const writeTo = async (keys, src, dest) => {
            let needsReSort = false;
            for (const key of keys) {
                const hash = await src.get(key);
                if (!hash) {
                    continue;
                }
                if (hash instanceof Error) {
                    throw hash;
                }
                needsReSort = needsReSort || !Object.hasOwn(dest, key);
                dest[key] = hash;
            }
            if (needsReSort) {
                (0, utils_1.shallowSortObject)(dest);
            }
        };
        const markAsCommited = (keys, src) => {
            keys.forEach(key => src.set(key, null));
        };
        // Waiting for hashes to be calculated before locking file to reduce lock time
        await Promise.all([
            ...Object.values(this._stagedFileHashes),
            ...Object.values(this._stagedModuleHashes),
            ...Object.values(this._stagedPatternHashes),
        ]);
        const existingHashesContent = await (0, utils_1.readHashFileContents)(this._selectivityHashesPath, this._compresion);
        const [updatedModules, updatedFiles, updatedPatterns] = await Promise.all([
            filterMatchingHashes(stagedModuleNames, this._stagedModuleHashes, existingHashesContent.modules),
            filterMatchingHashes(stagedFileNames, this._stagedFileHashes, existingHashesContent.files),
            filterMatchingHashes(stagedPatternNames, this._stagedPatternHashes, existingHashesContent.patterns),
        ]);
        if (!updatedFiles.length && !updatedModules.length && !updatedPatterns.length) {
            return;
        }
        await Promise.all([
            writeTo(updatedModules, this._stagedModuleHashes, existingHashesContent.modules),
            writeTo(updatedFiles, this._stagedFileHashes, existingHashesContent.files),
            writeTo(updatedPatterns, this._stagedPatternHashes, existingHashesContent.patterns),
        ]);
        await (0, json_utils_1.writeJsonWithCompression)(this._selectivityHashesPath, existingHashesContent, this._compresion);
        markAsCommited(updatedModules, this._stagedModuleHashes);
        markAsCommited(updatedFiles, this._stagedFileHashes);
    }
}
exports.HashWriter = HashWriter;
exports.getHashWriter = (0, lodash_1.memoize)((testDependenciesPath, compression) => {
    return new HashWriter(testDependenciesPath, compression);
}, (testDependenciesPath, compression) => `${testDependenciesPath}#${compression}`);
//# sourceMappingURL=hash-writer.js.map