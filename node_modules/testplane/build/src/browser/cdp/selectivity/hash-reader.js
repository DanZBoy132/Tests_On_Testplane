"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHashReader = exports.HashReader = void 0;
const lodash_1 = require("lodash");
const node_path_1 = __importDefault(require("node:path"));
const hash_provider_1 = require("./hash-provider");
const utils_1 = require("./utils");
const debug_1 = require("./debug");
class HashReader {
    constructor(selectivityRootPath, compression) {
        this._hashProvider = new hash_provider_1.HashProvider();
        this._hashFileContents = null;
        this._selectivityHashesPath = (0, utils_1.getSelectivityHashesPath)(selectivityRootPath);
        this._compresion = compression;
    }
    _getHashFileContents() {
        if (this._hashFileContents) {
            return this._hashFileContents;
        }
        return (this._hashFileContents = (0, utils_1.readHashFileContents)(this._selectivityHashesPath, this._compresion));
    }
    _readHashForFile(filePath) {
        return this._getHashFileContents().then(hashFileContents => hashFileContents.files[filePath]);
    }
    _readHashForModule(moduleName) {
        return this._getHashFileContents().then(hashFileContents => hashFileContents.modules[moduleName]);
    }
    _readHashForPattern(pattern) {
        return this._getHashFileContents().then(hashFileContents => hashFileContents.patterns[pattern]);
    }
    async patternHasChanged(pattern) {
        const [cachedPatternHash, calculatedPatternHash] = await Promise.all([
            this._readHashForPattern(pattern),
            this._hashProvider.calculateForPattern(pattern),
        ]);
        return cachedPatternHash !== calculatedPatternHash;
    }
    /** @returns changed deps or null, if nothing changed */
    async getTestChangedDeps(testDeps) {
        const depFileTypes = ["css", "js", "modules"];
        const result = { css: [], js: [], modules: [] };
        let hasAnythingChanged = false;
        const checkForDepFileType = async (depFileType) => {
            await Promise.all(testDeps[depFileType].map(async (filePath) => {
                const adjustedFilePath = depFileType === "modules" ? node_path_1.default.join(filePath, "package.json") : filePath;
                const [cachedFileHash, calculatedFileHash] = await Promise.all([
                    depFileType === "modules" ? this._readHashForModule(filePath) : this._readHashForFile(filePath),
                    this._hashProvider.calculateForFile(adjustedFilePath).catch((err) => err),
                ]);
                if (calculatedFileHash instanceof Error) {
                    (0, debug_1.debugSelectivity)(`Couldn't calculate hash for ${adjustedFilePath}: ${calculatedFileHash.message}`);
                }
                if (cachedFileHash !== calculatedFileHash) {
                    hasAnythingChanged = true;
                    result[depFileType].push(filePath);
                }
            }));
        };
        await Promise.all(depFileTypes.map(depFileType => checkForDepFileType(depFileType)));
        return hasAnythingChanged ? result : null;
    }
}
exports.HashReader = HashReader;
exports.getHashReader = (0, lodash_1.memoize)((selectivityRootPath, compression) => {
    return new HashReader(selectivityRootPath, compression);
}, (selectivityRootPath, compression) => `${selectivityRootPath}#${compression}`);
//# sourceMappingURL=hash-reader.js.map