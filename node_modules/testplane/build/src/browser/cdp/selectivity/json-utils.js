"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeJsonWithCompression = exports.readJsonWithCompression = void 0;
const node_path_1 = __importDefault(require("node:path"));
const node_zlib_1 = __importDefault(require("node:zlib"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const types_1 = require("./types");
const getCompressionPrefix = (type) => (type === "none" ? "" : "." + type);
const compressionPriorities = process.versions.zstd
    ? [types_1.Compression.ZSTD, types_1.Compression.GZIP, types_1.Compression.BROTLI, types_1.Compression.NONE]
    : [types_1.Compression.GZIP, types_1.Compression.BROTLI, types_1.Compression.NONE];
const getExistingJsonPathWithCompression = (jsonBasePath, preferredCompressionType) => {
    const jsonPathWithPrefix = jsonBasePath + getCompressionPrefix(preferredCompressionType);
    if (fs_extra_1.default.existsSync(jsonPathWithPrefix)) {
        return { jsonPath: jsonPathWithPrefix, compressionType: preferredCompressionType };
    }
    for (const compressionType of compressionPriorities) {
        if (compressionType === preferredCompressionType) {
            continue;
        }
        const jsonPathWithCurrentPrefix = jsonBasePath + getCompressionPrefix(compressionType);
        if (fs_extra_1.default.existsSync(jsonPathWithCurrentPrefix)) {
            return { jsonPath: jsonPathWithCurrentPrefix, compressionType: compressionType };
        }
    }
    return { jsonPath: null, compressionType: preferredCompressionType };
};
const readCompressedTextFile = (filePath, compression) => {
    return new Promise((resolve, reject) => {
        let fileData = "";
        const readStream = fs_extra_1.default.createReadStream(filePath);
        let stream = readStream;
        if (compression === types_1.Compression.ZSTD && !("createZstdDecompress" in node_zlib_1.default)) {
            reject(new Error("zstd decompression is not supported in your version of node.js. Please, upgrade the node version to 22"));
        }
        switch (compression) {
            case types_1.Compression.ZSTD:
                stream = readStream.pipe(node_zlib_1.default.createZstdDecompress());
                break;
            case types_1.Compression.GZIP:
                stream = readStream.pipe(node_zlib_1.default.createGunzip());
                break;
            case types_1.Compression.BROTLI:
                stream = readStream.pipe(node_zlib_1.default.createBrotliDecompress());
                break;
        }
        stream.setEncoding("utf8");
        stream.on("data", chunk => {
            fileData += chunk;
        });
        stream.on("end", () => {
            resolve(fileData);
        });
        stream.on("error", err => {
            reject(new Error(`Couldn't read ${filePath} with ${compression} compression:\n${err}`));
        });
    });
};
const writeCompressedTextFile = (filePath, data, compression) => {
    return new Promise((resolve, reject) => {
        const writeStream = fs_extra_1.default.createWriteStream(filePath);
        let stream = writeStream;
        if (compression === types_1.Compression.ZSTD && !("createZstdCompress" in node_zlib_1.default)) {
            reject(new Error("zstd compression is not supported in your version of node.js. Please, upgrade the node version to 22"));
        }
        switch (compression) {
            case types_1.Compression.ZSTD:
                stream = node_zlib_1.default.createZstdCompress();
                stream.pipe(writeStream);
                break;
            case types_1.Compression.GZIP:
                stream = node_zlib_1.default.createGzip();
                stream.pipe(writeStream);
                break;
            case types_1.Compression.BROTLI:
                stream = node_zlib_1.default.createBrotliCompress();
                stream.pipe(writeStream);
                break;
        }
        stream.write(data, "utf8", err => {
            if (err) {
                reject(new Error(`Couldn't write to ${filePath} with ${compression} compression:\n${err}`));
            }
            else {
                stream.end();
            }
        });
        writeStream.on("finish", () => {
            resolve();
        });
        writeStream.on("error", err => {
            reject(new Error(`Couldn't save to ${filePath} with ${compression} compression:\n${err}`));
        });
    });
};
/**
 * @param jsonBasePath json path without compression suffix
 * @param preferredCompressionType
 * @returns decompressed and parsed JSON
 */
const readJsonWithCompression = async (jsonBasePath, preferredCompressionType, opts) => {
    const { jsonPath, compressionType } = getExistingJsonPathWithCompression(jsonBasePath, preferredCompressionType);
    if (!jsonPath) {
        if (opts?.defaultValue) {
            return Promise.resolve(opts.defaultValue);
        }
        else {
            throw new Error(`Couldn't read ${jsonBasePath} with following compression: ${compressionPriorities}: file does not exist`);
        }
    }
    const fileData = await readCompressedTextFile(jsonPath, compressionType);
    return JSON.parse(fileData);
};
exports.readJsonWithCompression = readJsonWithCompression;
const writeJsonWithCompression = async (jsonBasePath, data, preferredCompressionType) => {
    const filePath = jsonBasePath + getCompressionPrefix(preferredCompressionType);
    const fileData = JSON.stringify(data, null, preferredCompressionType === "none" ? 2 : 0);
    await fs_extra_1.default.ensureDir(node_path_1.default.dirname(filePath));
    return writeCompressedTextFile(filePath, fileData, preferredCompressionType);
};
exports.writeJsonWithCompression = writeJsonWithCompression;
//# sourceMappingURL=json-utils.js.map