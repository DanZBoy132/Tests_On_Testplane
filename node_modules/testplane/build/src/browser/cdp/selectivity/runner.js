"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectivityRunner = void 0;
const lodash_1 = __importDefault(require("lodash"));
const debug_1 = require("./debug");
const hash_reader_1 = require("./hash-reader");
const events_1 = require("../../../events");
const hash_writer_1 = require("./hash-writer");
const test_dependencies_reader_1 = require("./test-dependencies-reader");
/** Called at the start of testplane run per each browser */
const shouldDisableBrowserSelectivity = lodash_1.default.memoize(async (config, browserId) => {
    if (!config.selectivity.enabled) {
        return true;
    }
    if (!config.selectivity.disableSelectivityPatterns.length) {
        return false;
    }
    const hashReader = (0, hash_reader_1.getHashReader)(config.selectivity.testDependenciesPath, config.selectivity.compression);
    return new Promise(resolve => {
        let isSettled = false;
        Promise.all(config.selectivity.disableSelectivityPatterns.map(pattern => {
            return hashReader
                .patternHasChanged(pattern)
                .then(hasChanged => {
                if (hasChanged && !isSettled) {
                    isSettled = true;
                    (0, debug_1.debugSelectivity)(`Disabling selectivity for ${browserId}: file change by pattern "${pattern}" is detected`);
                    resolve(true);
                }
            })
                .catch(err => {
                if (!isSettled) {
                    isSettled = true;
                    (0, debug_1.debugSelectivity)(`Disabling selectivity for ${browserId}: got an error while checking 'disableSelectivityPatterns': %O`, err);
                    resolve(true);
                }
            });
        })).then(() => {
            if (!isSettled) {
                (0, debug_1.debugSelectivity)(`None of 'disableSelectivityPatterns' is changed for ${browserId}`);
                resolve(false);
            }
        });
    });
}, config => {
    const { enabled, testDependenciesPath, compression, disableSelectivityPatterns } = config.selectivity;
    return enabled
        ? enabled + "#" + testDependenciesPath + "#" + compression + "#" + disableSelectivityPatterns.join("#")
        : "";
});
const shouldDisableTestBySelectivity = lodash_1.default.memoize(async (config, test) => {
    const { enabled, testDependenciesPath, compression } = config.selectivity;
    if (!enabled) {
        return false;
    }
    const testDepsReader = (0, test_dependencies_reader_1.getTestDependenciesReader)(testDependenciesPath, compression);
    const hashReader = (0, hash_reader_1.getHashReader)(testDependenciesPath, compression);
    const testDeps = await testDepsReader.getFor(test);
    if (!testDeps.js.length) {
        (0, debug_1.debugSelectivity)(`Not disabling "${test.fullTitle()}" as it has no js deps and therefore it was considered as new`);
        return false;
    }
    const changedDeps = await hashReader.getTestChangedDeps(testDeps);
    if (changedDeps) {
        (0, debug_1.debugSelectivity)(`Not disabling "${test.fullTitle()}" as its dependencies were changed: %O`, changedDeps);
    }
    else {
        (0, debug_1.debugSelectivity)(`Disabling "${test.fullTitle()}" as its dependencies were not changed`);
    }
    return !changedDeps;
}, (config, test) => {
    const { enabled, testDependenciesPath, compression } = config.selectivity;
    return enabled ? enabled + "#" + testDependenciesPath + "#" + compression + "#" + test.id : "";
});
const onTestDependencies = (context, data) => {
    const hashWriter = (0, hash_writer_1.getHashWriter)(context.testDependenciesPath, context.compression);
    hashWriter.addTestDependencyHashes(data);
};
class SelectivityRunner {
    static create(...args) {
        return new this(...args);
    }
    constructor(mainRunner, config, runTestFn, opts) {
        this._browserSelectivityDisabledCache = {};
        this._processingTestPromises = [];
        this._config = config;
        this._runTestFn = runTestFn;
        this._opts = opts;
        if (this._opts?.shouldDisableSelectivity) {
            (0, debug_1.debugSelectivity)("Test filter is specified, disabling selectivity");
        }
        else {
            mainRunner.on(events_1.MasterEvents.TEST_DEPENDENCIES, onTestDependencies);
        }
    }
    _shouldDisableSelectivityForBrowser(browserId) {
        if (this._browserSelectivityDisabledCache[browserId]) {
            return this._browserSelectivityDisabledCache[browserId];
        }
        const browserConfig = this._config.forBrowser(browserId);
        this._browserSelectivityDisabledCache[browserId] = shouldDisableBrowserSelectivity(browserConfig, browserId);
        return this._browserSelectivityDisabledCache[browserId];
    }
    startTestCheckToRun(test, browserId) {
        const browserConfig = this._config.forBrowser(browserId);
        const isSelectivityEnabledForBrowser = browserConfig.selectivity.enabled;
        // If selectivity is disabled for browser
        if (!isSelectivityEnabledForBrowser || this._opts?.shouldDisableSelectivity) {
            this._processingTestPromises.push(Promise.resolve([test, browserId]));
            return;
        }
        this._processingTestPromises.push((async () => {
            const shouldDisableBrowserSelectivity = await this._shouldDisableSelectivityForBrowser(browserId);
            if (shouldDisableBrowserSelectivity) {
                return [test, browserId];
            }
            const shouldDisableTest = await shouldDisableTestBySelectivity(browserConfig, test);
            if (!shouldDisableTest) {
                return [test, browserId];
            }
            return null;
        })());
    }
    async runNecessaryTests() {
        const testsToRun = await Promise.all(this._processingTestPromises);
        for (const testToRun of testsToRun) {
            if (!testToRun) {
                continue;
            }
            const [test, browserId] = testToRun;
            // All tests need to be started synchronously
            this._runTestFn(test, browserId);
        }
        // Free used memory
        this._processingTestPromises.length = 0;
    }
}
exports.SelectivityRunner = SelectivityRunner;
//# sourceMappingURL=runner.js.map