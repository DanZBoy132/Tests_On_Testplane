import { type RawSourceMap } from "source-map-js";
import type { CDPRuntime } from "../domains/runtime";
import type { CDPSessionId } from "../types";
import type { HashFileContents, NormalizedDependencies, SelectivityCompressionType } from "./types";
import type { Test } from "../../../types";
/**
 * Tries to fetch text by url from node.js, then falls back to "fetch" from browser, if node.js fetch fails
 * @param url text url
 * @param runtime CDP runtime domain
 * @param sessionId CDP session id
 * @returns text
 */
export declare const fetchTextWithBrowserFallback: (url: string, runtime: CDPRuntime, sessionId: CDPSessionId) => Promise<string | Error>;
/**
 * Replaces "webpack://" protocol with source path because "source-map" doesn't work well with protocol paths
 * @param sourceMap Raw source maps in https://tc39.es/ecma426/ format
 * @param sourceRoot Source root
 */
export declare const patchSourceMapSources: (sourceMap: RawSourceMap, sourceRoot?: string) => RawSourceMap;
/**
 * Given compiled code, its source map, and the executed offsets
 * It returns the original source files touched
 * Useful for turning coverage ranges into real TS/JS module dependencies
 * @param source Compiled source code
 * @param sourceMaps Source maps JSON string
 * @param startOffsets Executed start offsets (v8 format)
 * @param sourceRoot Source root
 */
export declare const extractSourceFilesDeps: (source: string, sourceMaps: string, startOffsets: number[], sourceRoot: string) => Promise<Set<string>>;
/**
 * @returns True, if fileUrlLikePath has some kind of protocol ("data://", "webpack://", "turbopack://", "file://")...
 */
export declare const hasProtocol: (fileUrlLikePath: string) => boolean;
/**
 * @param cssDependencies set of css dependenciy URI's
 * @param jsDependencies set of js dependenciy URI's
 * @returns sorted uniq arrays of relative paths
 */
export declare const transformSourceDependencies: (cssDependencies: Set<string> | null, jsDependencies: Set<string> | null, mapDependencyPathFn?: ((relativePath: string) => string | void) | null | undefined) => NormalizedDependencies;
/** Merges two sorted deps array into one with uniq values */
export declare const mergeSourceDependencies: (a: NormalizedDependencies, b: NormalizedDependencies) => NormalizedDependencies;
export declare const shallowSortObject: (obj: Record<string, unknown>) => void;
export declare const getSelectivityHashesPath: (testDependenciesPath: string) => string;
export declare const readHashFileContents: (selectivityHashesPath: string, compression: SelectivityCompressionType) => Promise<HashFileContents>;
export declare const getSelectivityTestsPath: (testDependenciesPath: string) => string;
export declare const getTestDependenciesPath: (selectivityTestsPath: string, test: Test) => string;
/** @returns `Promise<Record<BrowserID, Record<DepType, NormalizedDependencies>>>` */
export declare const readTestDependencies: (selectivityTestsPath: string, test: Test, compression: SelectivityCompressionType) => Promise<Record<string, Record<string, NormalizedDependencies>>>;
