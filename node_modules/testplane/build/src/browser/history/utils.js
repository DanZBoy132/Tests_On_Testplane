"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldRecordSnapshots = exports.runWithHooks = exports.isGroup = exports.normalizeCommandArgs = void 0;
const util_1 = require("util");
const types_1 = require("util/types");
const lodash_1 = __importDefault(require("lodash"));
const types_2 = require("../../types");
const config_1 = require("../../config");
const MAX_STRING_LENGTH = 50;
const normalizeCommandArgs = (commandName, args = []) => {
    if (commandName === "execute") {
        return ["code"];
    }
    return args.map(arg => {
        try {
            if (typeof arg === "string") {
                return lodash_1.default.truncate(arg, { length: MAX_STRING_LENGTH });
            }
            if ((0, types_1.isPromise)(arg)) {
                return "promise";
            }
            if (lodash_1.default.isPlainObject(arg)) {
                return lodash_1.default.truncate((0, util_1.inspect)(arg, { depth: 0, compact: true, breakLength: Infinity, maxArrayLength: 10 }), { length: MAX_STRING_LENGTH });
            }
            return lodash_1.default.truncate(String(arg), { length: MAX_STRING_LENGTH });
        }
        catch (err) {
            return "unknown";
        }
    });
};
exports.normalizeCommandArgs = normalizeCommandArgs;
const isGroup = (node) => Boolean(node && node[types_2.TestStepKey.IsGroup]);
exports.isGroup = isGroup;
const runWithHooks = ({ fn, before, after, error }) => {
    let isReturnedValuePromise = false;
    before();
    try {
        const value = fn();
        if ((0, types_1.isPromise)(value)) {
            isReturnedValuePromise = true;
            return value
                .catch((err) => {
                error(err);
                throw err;
            })
                .finally(after)
                .then(() => value); // It's valid to convert Promise to T since value is already Promise here
        }
        return value;
    }
    catch (err) {
        if (!isReturnedValuePromise) {
            error(err);
        }
        throw err;
    }
    finally {
        if (!isReturnedValuePromise) {
            after();
        }
    }
};
exports.runWithHooks = runWithHooks;
const shouldRecordSnapshots = (timeTravelMode, isRetry) => {
    return (timeTravelMode === config_1.TimeTravelMode.On ||
        timeTravelMode === config_1.TimeTravelMode.LastFailedRun ||
        (timeTravelMode === config_1.TimeTravelMode.RetriesOnly && isRetry));
};
exports.shouldRecordSnapshots = shouldRecordSnapshots;
//# sourceMappingURL=utils.js.map