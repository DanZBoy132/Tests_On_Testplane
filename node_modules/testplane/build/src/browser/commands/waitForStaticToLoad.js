"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger = __importStar(require("../../utils/logger"));
/* eslint-disable no-var */
function browserIsPageReady() {
    if (document.readyState === "loading") {
        return { ready: false, reason: "Document is loading" };
    }
    if (document.currentScript) {
        return { ready: false, reason: "JavaScript is running" };
    }
    if (document.fonts && document.fonts.status === "loading") {
        return { ready: false, reason: "Fonts are loading" };
    }
    var imagesCount = (document.images && document.images.length) || 0;
    for (var i = 0; i < imagesCount; i++) {
        var image = document.images.item(i);
        if (image && !image.complete) {
            return { ready: false, reason: `Image from ${image.src} is loading` };
        }
    }
    var externalStyles = document.querySelectorAll('link[rel="stylesheet"]');
    var externalStylesCount = (externalStyles && externalStyles.length) || 0;
    for (var i = 0; i < externalStylesCount; i++) {
        var style = externalStyles.item(i);
        if (!style.sheet) {
            return { ready: false, reason: `Styles from ${style.href} are loading` };
        }
    }
    var waitingForResourceUrls = new Set();
    var nodesWithInlineStylesWithUrl = document.querySelectorAll('[style*="url("]');
    var styleWithUrlRegExp = /^url\("(.*)"\)$/;
    for (var node of nodesWithInlineStylesWithUrl) {
        if (!node.clientHeight || !node.clientWidth) {
            continue;
        }
        var inlineRulesCount = node.style ? node.style.length : 0;
        for (var i = 0; i < inlineRulesCount; i++) {
            var inlineRuleName = node.style[i];
            var inlineRuleValue = node.style[inlineRuleName];
            if (!inlineRuleValue || (!inlineRuleValue.startsWith('url("') && !inlineRuleValue.startsWith("url('"))) {
                continue;
            }
            var computedStyleValue = getComputedStyle(node).getPropertyValue(inlineRuleName);
            var match = styleWithUrlRegExp.exec(computedStyleValue);
            if (match && match[1] && !match[1].startsWith("data:")) {
                waitingForResourceUrls.add(match[1]);
            }
        }
    }
    for (var styleSheet of document.styleSheets) {
        try {
            for (var cssRules of styleSheet.cssRules) {
                var cssStyleRule = cssRules;
                var cssStyleSelector = cssStyleRule.selectorText;
                var cssStyleRulesCount = cssStyleRule.style ? cssStyleRule.style.length : 0;
                var displayedNodeElementsStyles = null;
                for (var i = 0; i < cssStyleRulesCount; i++) {
                    var cssRuleName = cssStyleRule.style[i];
                    var cssRuleValue = cssStyleRule.style[cssRuleName];
                    if (!cssRuleValue || (!cssRuleValue.startsWith('url("') && !cssRuleValue.startsWith("url('"))) {
                        continue;
                    }
                    if (!displayedNodeElementsStyles) {
                        displayedNodeElementsStyles = [];
                        document.querySelectorAll(cssStyleSelector).forEach(function (node) {
                            if (!node.clientHeight || !node.clientWidth) {
                                return;
                            }
                            displayedNodeElementsStyles.push(getComputedStyle(node));
                        });
                    }
                    for (var nodeStyles of displayedNodeElementsStyles) {
                        var computedStyleValue = nodeStyles.getPropertyValue(cssRuleName);
                        var match = styleWithUrlRegExp.exec(computedStyleValue);
                        if (match && match[1] && !match[1].startsWith("data:")) {
                            waitingForResourceUrls.add(match[1]);
                        }
                    }
                }
            }
        }
        catch (err) { } // eslint-disable-line no-empty
    }
    var performanceResourceEntries = performance.getEntriesByType("resource");
    performanceResourceEntries.forEach(function (performanceResourceEntry) {
        waitingForResourceUrls.delete(performanceResourceEntry.name);
    });
    if (!waitingForResourceUrls.size) {
        return { ready: true };
    }
    var pendingResources = Array.from(waitingForResourceUrls);
    return { ready: false, reason: "Resources are not loaded", pendingResources };
}
function browserAreResourcesLoaded(pendingResources) {
    var pendingResourcesSet = new Set(pendingResources);
    var performanceResourceEntries = performance.getEntriesByType("resource");
    performanceResourceEntries.forEach(function (performanceResourceEntry) {
        pendingResourcesSet.delete(performanceResourceEntry.name);
    });
    return Array.from(pendingResourcesSet);
}
exports.default = (browser) => {
    const { publicAPI: session } = browser;
    session.addCommand("waitForStaticToLoad", async function ({ timeout = browser.config.waitTimeout, interval = browser.config.waitInterval, } = {}) {
        let isTimedOut = false;
        const loadTimeout = setTimeout(() => {
            isTimedOut = true;
        }, timeout).unref();
        const warnTimedOut = (result) => {
            const timedOutMsg = `Timed out waiting for page to load in ${timeout}ms.`;
            if (result && result.pendingResources) {
                logger.warn([
                    `${timedOutMsg} Several resources are still not loaded:`,
                    ...result.pendingResources.map(resouce => `- ${resouce}`),
                ].join("\n"));
            }
            else {
                logger.warn(`${timedOutMsg} ${result.reason}`);
            }
        };
        let result = await session.execute(browserIsPageReady);
        while (!isTimedOut && !result.ready) {
            await new Promise(resolve => setTimeout(resolve, interval));
            if (result.pendingResources) {
                result.pendingResources = await session.execute(browserAreResourcesLoaded, result.pendingResources);
                result.ready = result.pendingResources.length === 0;
            }
            else {
                result = await session.execute(browserIsPageReady);
            }
        }
        clearTimeout(loadTimeout);
        if (isTimedOut && !result.ready) {
            warnTimedOut(result);
        }
        if (result.ready) {
            return { ready: true };
        }
        if (result.reason === "Resources are not loaded") {
            return { ready: false, reason: "Resources are not loaded", pendingResources: result.pendingResources };
        }
        return { ready: false, reason: result.reason };
    });
};
//# sourceMappingURL=waitForStaticToLoad.js.map