"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWebdriverFrames = exports.getOverridesProtocol = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const dumpStorage_1 = require("./dumpStorage");
const config_1 = require("../../../constants/config");
const existing_browser_1 = require("../../existing-browser");
const logger = __importStar(require("../../../utils/logger"));
const events_1 = require("../../../events");
const globalFilesToRemove_1 = require("../../../globalFilesToRemove");
// in case when we use webdriver protocol, bidi and isolation
// we have to force change protocol to devtools, for use puppeteer,
// because we use it for create incognito window
const getOverridesProtocol = (browser) => browser.config.automationProtocol === config_1.WEBDRIVER_PROTOCOL && browser.publicAPI.isBidi && browser.config.isolation
    ? config_1.DEVTOOLS_PROTOCOL
    : browser.config.automationProtocol;
exports.getOverridesProtocol = getOverridesProtocol;
const getWebdriverFrames = async (session) => session.execute(() => Array.from(document.getElementsByTagName("iframe"))
    .map(el => el.getAttribute("src"))
    .filter(src => src !== null && src !== "about:blank"));
exports.getWebdriverFrames = getWebdriverFrames;
exports.default = (browser) => {
    const { publicAPI: session } = browser;
    session.addCommand("saveState", async (_options = {}) => {
        const currentUrl = new URL(await session.getUrl());
        if (!currentUrl.origin || currentUrl.origin === "null") {
            throw new Error("Before saveState first open page using url command");
        }
        const options = { ...browser.config.stateOpts, ..._options };
        const data = {
            framesData: {},
        };
        switch ((0, exports.getOverridesProtocol)(browser)) {
            case config_1.WEBDRIVER_PROTOCOL: {
                if (options.cookies) {
                    const cookies = await session.getAllCookies();
                    data.cookies = cookies.map(cookie => ({
                        ...cookie,
                        sameSite: cookie.sameSite ? lodash_1.default.startCase(cookie.sameSite) : cookie.sameSite,
                    }));
                }
                await session.switchToParentFrame();
                const frames = await (0, exports.getWebdriverFrames)(session);
                const framesData = {};
                for (let i = 0; i <= frames.length; i++) {
                    await session.switchToParentFrame();
                    // after last element have to get data from parent frame
                    if (i < frames.length) {
                        await session.switchFrame(await session.$(`iframe[src="${frames[i]}"]`));
                    }
                    const origin = await session.execute(() => window.location.origin);
                    if (!origin || origin === "null" || framesData[origin]) {
                        continue;
                    }
                    const frameData = {};
                    if (options.localStorage || options.sessionStorage) {
                        const { localStorage, sessionStorage } = await session.execute(dumpStorage_1.dumpStorage);
                        if (localStorage && options.localStorage) {
                            frameData.localStorage = localStorage;
                        }
                        if (sessionStorage && options.sessionStorage) {
                            frameData.sessionStorage = sessionStorage;
                        }
                    }
                    if (frameData.localStorage || frameData.sessionStorage) {
                        framesData[origin] = frameData;
                    }
                }
                await session.switchToParentFrame();
                data.framesData = framesData;
                break;
            }
            case config_1.DEVTOOLS_PROTOCOL: {
                if (options.cookies) {
                    const cookies = await session.getAllCookies();
                    data.cookies = cookies.map(cookie => ({
                        ...cookie,
                        sameSite: cookie.sameSite ? lodash_1.default.startCase(cookie.sameSite) : cookie.sameSite,
                    }));
                }
                const page = await (0, existing_browser_1.getActivePuppeteerPage)(session);
                if (!page) {
                    break;
                }
                const frames = page.frames();
                const framesData = {};
                for (const frame of frames) {
                    const origin = new URL(frame.url()).origin;
                    if (origin === "null" || framesData[origin]) {
                        continue;
                    }
                    const frameData = {};
                    if (options.localStorage || options.sessionStorage) {
                        const { localStorage, sessionStorage } = await frame.evaluate(dumpStorage_1.dumpStorage);
                        if (localStorage && options.localStorage) {
                            frameData.localStorage = localStorage;
                        }
                        if (sessionStorage && options.sessionStorage) {
                            frameData.sessionStorage = sessionStorage;
                        }
                    }
                    if (frameData.localStorage || frameData.sessionStorage) {
                        framesData[origin] = frameData;
                    }
                }
                data.framesData = framesData;
                break;
            }
        }
        if (options && options.cookieFilter && data.cookies) {
            data.cookies = data.cookies.filter(options.cookieFilter);
        }
        const dataIsEmpty = data.cookies?.length === 0 && lodash_1.default.isEmpty(data.framesData);
        if (options && options.path && !dataIsEmpty) {
            await fs_extra_1.default.outputJson(options.path, data, { spaces: 2 });
            if (options.keepFile) {
                logger.warn("\x1b[31mOption keepFile in stateOpts now is true. Please be aware that the file containing authorization data will not be automatically deleted after the tests are completed!\x1b[0m");
            }
            else {
                if (process.send) {
                    process.send({
                        event: events_1.MasterEvents.ADD_FILE_TO_REMOVE,
                        data: options.path,
                    });
                }
                (0, globalFilesToRemove_1.addGlobalFileToRemove)(options.path);
                browser.emitter.emit(events_1.MasterEvents.ADD_FILE_TO_REMOVE, options.path);
            }
        }
        return data;
    });
};
//# sourceMappingURL=index.js.map