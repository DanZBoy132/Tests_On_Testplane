"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.launchBrowser = void 0;
const config_1 = require("../../config");
const new_browser_1 = require("./../new-browser");
const existing_browser_1 = require("./../existing-browser");
const calibrator_1 = require("./../calibrator");
const events_1 = require("../../events");
const types_1 = require("./../types");
const browser_1 = require("../../utils/browser");
const config_2 = require("../../constants/config");
const webdriver_pool_1 = require("../../browser-pool/webdriver-pool");
const fs_extra_1 = __importDefault(require("fs-extra"));
const globalFilesToRemove_1 = require("../../globalFilesToRemove");
const webdriverPool = new webdriver_pool_1.WebdriverPool();
async function launchBrowser(options = {}) {
    const desiredCapabilities = options.desiredCapabilities || {};
    const browserName = desiredCapabilities.browserName || types_1.BrowserName.CHROME;
    const normalizedBrowserName = (0, browser_1.getNormalizedBrowserName)(browserName);
    if (!normalizedBrowserName) {
        throw new Error([
            `Running browser "${browserName}" is unsupported`,
            `Supported browsers: "chrome", "firefox", "safari", "edge"`,
        ].join("\n"));
    }
    const browserConfig = {
        desiredCapabilities: {
            browserName,
            ...desiredCapabilities,
        },
        gridUrl: options.gridUrl || config_2.LOCAL_GRID_URL,
        baseUrl: options.baseUrl,
        headless: options.headless !== undefined ? options.headless : true,
        pageLoadTimeout: options.pageLoadTimeout,
        httpTimeout: options.httpTimeout,
        waitTimeout: options.waitTimeout,
        waitInterval: options.waitInterval,
        automationProtocol: options.automationProtocol,
        windowSize: options.windowSize,
        orientation: options.orientation,
        headers: options.headers,
        strictSSL: options.strictSSL,
        user: options.user,
        key: options.key,
        prepareBrowser: options.prepareBrowser,
        stateOpts: options.stateOpts,
    };
    const filesToRemove = [];
    const config = new config_1.Config({
        browsers: {
            [browserName]: browserConfig,
        },
    });
    if (!process.env.WDIO_LOG_LEVEL) {
        process.env.WDIO_LOG_LEVEL = config.system.debug ? "trace" : "error";
    }
    const emitter = new events_1.AsyncEmitter();
    emitter.on(events_1.MasterEvents.ADD_FILE_TO_REMOVE, (path) => {
        filesToRemove.push(path);
    });
    const newBrowser = new new_browser_1.NewBrowser(config, {
        id: browserName,
        version: desiredCapabilities.browserVersion,
        emitter,
        wdPool: webdriverPool,
    });
    await newBrowser.init();
    const existingBrowser = new existing_browser_1.ExistingBrowser(config, {
        id: browserName,
        version: desiredCapabilities.browserVersion,
        emitter,
        state: {},
    });
    const calibrator = new calibrator_1.Calibrator();
    const session = newBrowser.publicAPI;
    await existingBrowser.init({
        sessionId: session.sessionId,
        sessionCaps: session.capabilities,
        sessionOpts: {
            capabilities: session.capabilities,
            ...session.options,
        },
    }, calibrator);
    existingBrowser.publicAPI.overwriteCommand("deleteSession", async function () {
        await existingBrowser.quit();
        await newBrowser.kill();
        if (filesToRemove.length > 0 && !(0, globalFilesToRemove_1.hasGlobalFilesToRemove)()) {
            await Promise.all(filesToRemove.map(path => fs_extra_1.default.remove(path)));
        }
    });
    existingBrowser.publicAPI.addCommand("getDriverPid", () => newBrowser.getDriverPid());
    return existingBrowser.publicAPI;
}
exports.launchBrowser = launchBrowser;
//# sourceMappingURL=launchBrowser.js.map