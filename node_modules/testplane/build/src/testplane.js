"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Testplane = void 0;
const lodash_1 = __importDefault(require("lodash"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const stats_1 = require("./stats");
const base_testplane_1 = require("./base-testplane");
const runtime_config_1 = __importDefault(require("./config/runtime-config"));
const events_1 = require("./events");
const utils_1 = __importDefault(require("./events/utils"));
const signal_handler_1 = __importDefault(require("./signal-handler"));
const test_reader_1 = require("./test-reader");
const test_collection_1 = require("./test-collection");
const validators_1 = require("./validators");
const reporters_1 = require("./reporters");
const logger = __importStar(require("./utils/logger"));
const config_1 = require("./utils/config");
const dev_server_1 = require("./dev-server");
const preload_utils_1 = require("./utils/preload-utils");
const selectivity_1 = require("./browser/cdp/selectivity");
const server_1 = require("./runner/browser-env/vite/server");
const globalFilesToRemove_1 = require("./globalFilesToRemove");
const tests_tracker_1 = require("./runner/tests-tracker");
const unhandled_rejection_error_1 = require("./errors/unhandled-rejection-error");
class Testplane extends base_testplane_1.BaseTestplane {
    constructor(config) {
        super(config);
        this.failed = false;
        this.failedList = [];
        this.runner = null;
        this.viteServer = null;
        this._filesToRemove = [];
        this.testsTracker = null;
    }
    extendCli(parser) {
        this.emit(events_1.MasterEvents.CLI, parser);
    }
    addFileToRemove(path) {
        this._filesToRemove.push(path);
    }
    async _init() {
        await (0, dev_server_1.initDevServer)({
            testplane: this,
            devServerConfig: this._config.devServer,
            configPath: this._config.configPath,
        });
        if (!(0, config_1.isRunInNodeJsEnv)(this._config)) {
            try {
                this.viteServer = server_1.ViteServer.create(this._config);
                await this.viteServer.start();
            }
            catch (err) {
                throw new Error(`Vite server failed to start: ${err.message}`);
            }
        }
        return super._init();
    }
    async run(testPaths, { browsers, sets, grep, tag, updateRefs, requireModules, inspectMode, replMode, devtools, local, keepBrowserMode, reporters = [], } = {}) {
        (0, validators_1.validateUnknownBrowsers)(browsers, lodash_1.default.keys(this._config.browsers));
        runtime_config_1.default.getInstance().extend({
            updateRefs,
            requireModules,
            inspectMode,
            replMode,
            devtools,
            local,
            keepBrowserMode,
        });
        if (replMode?.enabled) {
            this._config.system.mochaOpts.timeout = 0;
        }
        const RunnerClass = await Promise.resolve().then(() => __importStar(require("./runner"))).then(m => m.MainRunner);
        const runner = RunnerClass.create(this._config, this._interceptors);
        this.runner = runner;
        this.on(events_1.MasterEvents.TEST_FAIL, res => {
            this._fail();
            this._addFailedTest(res);
        });
        this.on(events_1.MasterEvents.ERROR, (err) => this._handleError(err));
        this.on(events_1.MasterEvents.RUNNER_END, async () => await this._saveFailed());
        this.on(events_1.MasterEvents.ADD_FILE_TO_REMOVE, this.addFileToRemove);
        this.testsTracker = new tests_tracker_1.TestsTracker(this);
        await (0, reporters_1.initReporters)(reporters, this);
        utils_1.default.passthroughEvent(this.runner, this, lodash_1.default.values(events_1.MasterSyncEvents));
        utils_1.default.passthroughEventAsync(this.runner, this, lodash_1.default.values(events_1.MasterAsyncEvents));
        utils_1.default.passthroughEventAsync(signal_handler_1.default, this, events_1.MasterEvents.EXIT);
        await this._init();
        runner.init();
        (0, preload_utils_1.preloadWebdriverIO)();
        (0, globalFilesToRemove_1.initGlobalFilesToRemove)();
        if (this.config.beforeAll) {
            await this.config.beforeAll.call({ config: this.config }, { config: this.config });
        }
        const hasTestPathsFilter = lodash_1.default.isArray(testPaths) ? Boolean(testPaths.length) : true;
        const hasTestFilter = hasTestPathsFilter || Boolean(sets?.length) || Boolean(grep) || Boolean(tag);
        const shouldDisableSelectivity = Boolean(hasTestFilter);
        await runner.run(await this._readTests(testPaths, { browsers, sets, grep, tag, replMode, keepBrowserMode }), stats_1.Stats.create(this), { shouldDisableSelectivity });
        if (!shouldDisableSelectivity && !this.isFailed()) {
            await (0, selectivity_1.updateSelectivityHashes)(this.config);
        }
        if (this.config.afterAll) {
            await this.config.afterAll.call({ config: this.config }, { config: this.config });
        }
        const filesToRemove = [...new Set([...this._filesToRemove, ...(0, globalFilesToRemove_1.getGlobalFilesToRemove)()])];
        if (filesToRemove.length > 0) {
            await Promise.all(filesToRemove.map(path => fs_extra_1.default.remove(path)));
        }
        return !this.isFailed();
    }
    async _saveFailed() {
        await fs_extra_1.default.outputJSON(this._config.lastFailed.output, this.failedList); // No spaces because users usually don't need to read it
    }
    async _readTests(testPaths, opts) {
        return testPaths instanceof test_collection_1.TestCollection ? testPaths : await this.readTests(testPaths, opts);
    }
    addTestToRun(test, browserId) {
        return this.runner ? this.runner.addTestToRun(test, browserId) : false;
    }
    async readTests(testPaths, { browsers, sets, grep, tag, silent, ignore, replMode, keepBrowserMode, runnableOpts, } = {}) {
        const testReader = test_reader_1.TestReader.create(this._config);
        if (!silent) {
            await this._init();
            utils_1.default.passthroughEvent(testReader, this, [
                events_1.MasterEvents.BEFORE_FILE_READ,
                events_1.MasterEvents.AFTER_FILE_READ,
            ]);
        }
        const specs = await testReader.read({
            paths: testPaths,
            browsers,
            ignore,
            sets,
            grep,
            tag,
            replMode,
            keepBrowserMode,
            runnableOpts,
        });
        const collection = test_collection_1.TestCollection.create(specs);
        collection.getBrowsers().forEach(bro => {
            if (this._config.forBrowser(bro).strictTestsOrder) {
                collection.sortTests(bro, ({ id: a }, { id: b }) => (a < b ? -1 : 1));
            }
        });
        if (!silent) {
            this.emit(events_1.MasterEvents.AFTER_TESTS_READ, collection);
        }
        return collection;
    }
    isFailed() {
        return this.failed;
    }
    _fail() {
        this.failed = true;
    }
    _addFailedTest(result) {
        this.failedList.push({
            fullTitle: result.fullTitle(),
            browserId: result.browserId,
            browserVersion: result.browserVersion,
        });
    }
    isWorker() {
        return false;
    }
    _handleError(err) {
        if (err && err.workerPid && this.testsTracker) {
            const allTests = this.testsTracker.getAllTests();
            const relevantTests = (0, tests_tracker_1.getTestsByWorkerPid)(allTests, err.workerPid);
            const topTests = relevantTests.slice(0, 5);
            const unhandledErrorWithAllTestsHint = new unhandled_rejection_error_1.UnhandledRejectionError({
                testsHint: (0, tests_tracker_1.formatTrackedTests)(relevantTests),
                workerPid: err.workerPid,
                error: err,
            });
            const unhandledErrorWithTopTestsHint = new unhandled_rejection_error_1.UnhandledRejectionError({
                testsHint: (0, tests_tracker_1.formatTrackedTests)(topTests),
                workerPid: err.workerPid,
                error: err,
            });
            this.once(events_1.MasterEvents.RUNNER_END, () => {
                logger.error("\n\n", logger.withLogOptions({ timestamp: false }));
                logger.error("Terminating on critical error:", unhandledErrorWithAllTestsHint);
            });
            // Slice tests list to 5 to avoid blowing up reporter size, because this message will be duplicated for each test
            this.halt(unhandledErrorWithTopTestsHint, 60000, false);
        }
        else {
            this.halt(err);
        }
    }
    halt(err, timeout = 60000, logError = true) {
        if (logError) {
            logger.error("Terminating on critical error:", err);
        }
        this._fail();
        if (timeout > 0) {
            setTimeout(() => {
                logger.error("Forcing shutdown...");
                logger.error(err);
                process.exit(1);
            }, timeout).unref();
        }
        if (this.viteServer) {
            this.viteServer.close();
        }
        if (this.runner) {
            this.runner.cancel(err);
        }
    }
}
exports.Testplane = Testplane;
//# sourceMappingURL=testplane.js.map