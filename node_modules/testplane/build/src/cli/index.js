"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = void 0;
const node_path_1 = __importDefault(require("node:path"));
const commander_1 = require("@gemini-testing/commander");
const get_port_1 = __importDefault(require("get-port"));
const defaults_1 = __importDefault(require("../config/defaults"));
const info_1 = require("./info");
const testplane_1 = require("../testplane");
const package_json_1 = __importDefault(require("../../package.json"));
const logger = __importStar(require("../utils/logger"));
const errors_1 = require("../utils/errors");
const secret_replacer_1 = require("../utils/secret-replacer");
const cli_1 = require("../utils/cli");
const constants_1 = require("./constants");
let testplane;
process.on("uncaughtException", err => {
    logger.error((0, secret_replacer_1.utilInspectSafe)(err));
    process.exit(1);
});
process.on("unhandledRejection", reason => {
    // This flag lets other unhandledRejection handlers know that we already processed it on Testplane side.
    // Currently we use this to avoid duplicate error logging and force shutdown in HTML Reporter.
    global["__TESTPLANE_INTERNAL_UNHANDLED_REJECTION_PROCESSED"] = true;
    if ((0, errors_1.shouldIgnoreUnhandledRejection)(reason)) {
        logger.warn(`Unhandled Rejection "${reason}" in testplane:master:${process.pid} was ignored`);
        return;
    }
    const error = [
        `Unhandled Rejection in testplane:master:${process.pid}:`,
        `Reason: ${(0, secret_replacer_1.utilInspectSafe)(reason)}`,
    ].join("\n");
    if (testplane) {
        testplane.halt(new Error(error));
    }
    else {
        logger.error(error);
        process.exit(1);
    }
});
const run = async (opts = {}) => {
    const program = new commander_1.Command(opts.cliName || "testplane");
    program.version(package_json_1.default.version).allowUnknownOption().option("-c, --config <path>", "path to configuration file");
    const programToParseRequires = new commander_1.Command(opts.cliName || "testplane")
        .version(package_json_1.default.version)
        .allowUnknownOption()
        .option("-r, --require <module>", "require module", cli_1.collectCliValues);
    const requireModules = preparseOption(programToParseRequires, "require");
    if (requireModules) {
        await (0, cli_1.handleRequires)(requireModules);
    }
    const configPath = preparseOption(program, "config");
    testplane = testplane_1.Testplane.create(configPath);
    (0, cli_1.withCommonCliOptions)({ cmd: program, actionName: "run" })
        .on("--help", () => console.log((0, info_1.configOverriding)(opts)))
        .description("Run tests")
        .option("--reporter <name>", "test reporters", cli_1.collectCliValues)
        .option("--update-refs", 'update screenshot references or gather them if they do not exist ("assertView" command)')
        .option("--inspect [inspect]", "nodejs inspector on [=[host:]port]")
        .option("--inspect-brk [inspect-brk]", "nodejs inspector with break at the start")
        .option("--repl [type]", "run one test, call `browser.switchToRepl` in test code to open repl interface", Boolean, false)
        .option("--repl-before-test [type]", "open repl interface before test run", Boolean, false)
        .option("--repl-on-fail [type]", "open repl interface on test fail only", Boolean, false)
        .option("--repl-port <number>", "run net server on port to exchange messages with repl (used free random port by default)", Number, 0)
        .option("--devtools", "switches the browser to the devtools mode with using CDP protocol")
        .option("--local", "use local browsers, managed by testplane (same as 'gridUrl': 'local')")
        .option("--keep-browser", "do not close browser session after test completion")
        .option("--keep-browser-on-fail", "do not close browser session when test fails")
        .arguments("[paths...]")
        .action(async (paths) => {
        try {
            const { reporter: reporters, browser: browsers, set: sets, grep, tag, updateRefs, inspect, inspectBrk, replBeforeTest, replOnFail, devtools, local, keepBrowser, keepBrowserOnFail, } = program;
            const isTestsSuccess = await testplane.run(paths, {
                reporters: reporters || defaults_1.default.reporters,
                browsers,
                sets,
                grep,
                tag,
                updateRefs,
                requireModules,
                inspectMode: (inspect || inspectBrk) && { inspect, inspectBrk },
                replMode: {
                    enabled: isReplModeEnabled(program),
                    beforeTest: replBeforeTest,
                    onFail: replOnFail,
                    port: await getReplPort(program),
                },
                devtools: devtools || false,
                local: local || false,
                keepBrowserMode: {
                    enabled: keepBrowser || keepBrowserOnFail || false,
                    onFail: keepBrowserOnFail || false,
                },
            });
            process.exit(isTestsSuccess ? 0 : 1);
        }
        catch (err) {
            logger.error(err.stack || err);
            process.exit(1);
        }
    });
    for (const commandName of Object.values(constants_1.CliCommands)) {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const { registerCmd } = require(node_path_1.default.resolve(__dirname, "./commands", commandName));
        registerCmd(program, testplane);
    }
    testplane.extendCli(program);
    program.parse(process.argv);
};
exports.run = run;
function preparseOption(program, option) {
    // do not display any help, do not exit
    const configFileParser = Object.create(program);
    configFileParser.options = [].concat(program.options);
    configFileParser.option("-h, --help");
    configFileParser.parse(process.argv);
    return configFileParser[option];
}
function isReplModeEnabled(program) {
    const { repl, replBeforeTest, replOnFail } = program;
    return repl || replBeforeTest || replOnFail;
}
async function getReplPort(program) {
    let { replPort } = program;
    if (isReplModeEnabled(program) && !replPort) {
        replPort = await (0, get_port_1.default)();
    }
    return replPort;
}
//# sourceMappingURL=index.js.map