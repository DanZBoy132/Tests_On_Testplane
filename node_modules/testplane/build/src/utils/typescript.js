"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.enableSourceMaps = exports.updateTransformHook = exports.registerTransformHook = exports.transformCode = void 0;
const node_path_1 = __importDefault(require("node:path"));
const pirates_1 = require("pirates");
const recast = __importStar(require("recast"));
const logger = __importStar(require("./logger"));
const config_1 = require("./config");
const TESTPLANE_TRANSFORM_HOOK = Symbol.for("testplane.transform.hook");
const TRANSFORM_CODE_EXTENSIONS = [".js", ".jsx", ".ts", ".tsx", ".mjs", ".cjs", ".mts", ".cts"];
const ASSET_EXTENSIONS = [
    ".css",
    ".scss",
    ".sass",
    ".less",
    ".styl",
    ".png",
    ".jpg",
    ".jpeg",
    ".gif",
    ".svg",
    ".woff",
    ".woff2",
];
let transformFunc = null;
let shouldRemoveViteQueryImports = false;
const transformCode = (code, { sourceFile, sourceMaps, isSilent = true }) => {
    if (transformFunc === null) {
        const envVar = process.env.TS_NODE_SWC === "false" ? false : true;
        const hasSwcCore = () => {
            try {
                require.resolve("@swc/core");
                return true;
            }
            catch {
                if (!isSilent) {
                    logger.warn(`testplane: you may install @swc/core for significantly faster reading of typescript tests.`);
                }
                return false;
            }
        };
        if (envVar && hasSwcCore()) {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const { transformSync } = require("@swc/core");
            transformFunc = (code, sourceFile, sourceMaps) => {
                const preprocessedCode = shouldRemoveViteQueryImports ? removeViteQueryImports(code, sourceFile) : code;
                return transformSync(preprocessedCode, {
                    sourceFileName: sourceFile,
                    sourceMaps: sourceMaps ? "inline" : false,
                    configFile: false,
                    swcrc: false,
                    minify: false,
                    module: {
                        type: "commonjs",
                        ignoreDynamic: true,
                    },
                    jsc: {
                        target: "esnext",
                        parser: {
                            syntax: "typescript",
                            tsx: true,
                            decorators: true,
                            dynamicImport: true,
                        },
                    },
                }).code;
            };
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const { transformSync } = require("esbuild");
            transformFunc = (code, sourceFile, sourceMaps) => {
                const preprocessedCode = shouldRemoveViteQueryImports ? removeViteQueryImports(code, sourceFile) : code;
                return transformSync(preprocessedCode, {
                    sourcefile: sourceFile,
                    sourcemap: sourceMaps ? "inline" : false,
                    minify: false,
                    loader: node_path_1.default.extname(sourceFile).includes("j") ? "jsx" : "tsx",
                    format: "cjs",
                    target: "esnext",
                    platform: "node",
                    jsx: "automatic",
                }).code;
            };
        }
    }
    return transformFunc(code, sourceFile, sourceMaps);
};
exports.transformCode = transformCode;
const registerTransformHook = (isSilent = false) => {
    const processWithTranspileSymbol = process;
    if (processWithTranspileSymbol[TESTPLANE_TRANSFORM_HOOK] || process.env.TS_ENABLE === "false") {
        return;
    }
    try {
        const mkTransformCodeHook = (sourceMaps = false) => (code, sourceFile) => (0, exports.transformCode)(code, { sourceFile, sourceMaps, isSilent });
        const transformCodeOptions = {
            exts: TRANSFORM_CODE_EXTENSIONS,
            ignoreNodeModules: true,
        };
        let areSourceMapsEnabled = false;
        let revertTransformHook = (0, pirates_1.addHook)(mkTransformCodeHook(), transformCodeOptions);
        const revertAssetHook = (0, pirates_1.addHook)(() => "module.exports = {};", {
            exts: ASSET_EXTENSIONS,
            ignoreNodeModules: false,
        });
        const enableSourceMaps = () => {
            if (areSourceMapsEnabled) {
                return;
            }
            areSourceMapsEnabled = true;
            revertTransformHook();
            revertTransformHook = (0, pirates_1.addHook)(mkTransformCodeHook(true), transformCodeOptions);
        };
        const revertAll = () => {
            revertTransformHook();
            revertAssetHook();
            delete processWithTranspileSymbol[TESTPLANE_TRANSFORM_HOOK];
        };
        processWithTranspileSymbol[TESTPLANE_TRANSFORM_HOOK] = { revert: revertAll, enableSourceMaps };
    }
    catch (err) {
        logger.warn(`testplane: an error occurred while trying to register transform hook.`, err);
    }
};
exports.registerTransformHook = registerTransformHook;
const updateTransformHook = (config) => {
    shouldRemoveViteQueryImports = (0, config_1.isRunInBrowserEnv)(config);
};
exports.updateTransformHook = updateTransformHook;
const enableSourceMaps = () => {
    const processWithTranspileSymbol = process;
    if (!processWithTranspileSymbol[TESTPLANE_TRANSFORM_HOOK]) {
        return;
    }
    processWithTranspileSymbol[TESTPLANE_TRANSFORM_HOOK].enableSourceMaps();
};
exports.enableSourceMaps = enableSourceMaps;
function removeViteQueryImports(code, sourceFile) {
    const extname = node_path_1.default.extname(sourceFile);
    const isJsxOrTsx = extname === ".jsx" || extname === ".tsx";
    if (!isJsxOrTsx) {
        return code;
    }
    let parser = null;
    try {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const babelParser = require("@babel/parser");
        parser = {
            parse(source) {
                return babelParser.parse(source, {
                    sourceType: "module",
                    plugins: [
                        "typescript",
                        "jsx",
                        "decorators-legacy",
                        "classProperties",
                        "nullishCoalescingOperator",
                        "optionalChaining",
                    ],
                    tokens: true,
                });
            },
        };
    }
    catch (err) {
        // If @babel/parser is not installed, return original code without transformation.
        // This is not a critical issue as the user may not be using Vite-style imports with query parameters.
        return code;
    }
    let ast;
    try {
        ast = recast.parse(code, {
            parser,
            sourceFileName: sourceFile,
            sourceRoot: node_path_1.default.dirname(sourceFile),
        });
    }
    catch (err) {
        const errorMessage = err.message;
        logger.warn(`Failed to parse file ${sourceFile} for removal of Vite query imports: ${errorMessage}. ` +
            `The file will be processed without removing query imports.`);
        return code;
    }
    recast.visit(ast, {
        visitImportDeclaration(nodePath) {
            const declaration = nodePath.value;
            const source = declaration.source.value;
            if (typeof source === "string") {
                const extname = node_path_1.default.extname(source);
                if (extname && extname.includes("?")) {
                    nodePath.prune();
                    return false;
                }
            }
            return this.traverse(nodePath);
        },
    });
    try {
        const result = recast.print(ast, { sourceMapName: sourceFile });
        return result.code;
    }
    catch (err) {
        const errorMessage = err.message;
        logger.warn(`Failed to transform AST for ${sourceFile} for removal of Vite query imports: ${errorMessage}. ` +
            `The file will be processed without removing query imports.`);
        return code;
    }
}
//# sourceMappingURL=typescript.js.map