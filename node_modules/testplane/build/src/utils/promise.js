"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.promiseMapSeries = exports.promiseDelay = exports.promiseTimeout = exports.promiseMethod = void 0;
function promiseMethod(fn) {
    return function (...args) {
        try {
            const result = fn.apply(this, args);
            return Promise.resolve(result);
        }
        catch (err) {
            return Promise.reject(err);
        }
    };
}
exports.promiseMethod = promiseMethod;
function promiseTimeout(promise, ms, message) {
    let timeoutId;
    let isCancelled = false;
    const timeoutPromise = new Promise((_, reject) => {
        timeoutId = setTimeout(() => {
            if (!isCancelled) {
                reject(new Error(message));
            }
        }, ms);
        if (timeoutId.unref) {
            timeoutId.unref();
        }
    });
    const wrappedPromise = new Promise((resolve, reject) => {
        promise.then(value => {
            if (!isCancelled) {
                resolve(value);
            }
        }, error => {
            if (!isCancelled) {
                reject(error);
            }
        });
    });
    return Promise.race([wrappedPromise, timeoutPromise]).finally(() => {
        isCancelled = true;
        clearTimeout(timeoutId);
    });
}
exports.promiseTimeout = promiseTimeout;
function promiseDelay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
exports.promiseDelay = promiseDelay;
async function promiseMapSeries(items, mapper) {
    const results = [];
    for (let i = 0; i < items.length; i++) {
        results.push(await Promise.resolve(mapper(items[i], i)));
    }
    return results;
}
exports.promiseMapSeries = promiseMapSeries;
//# sourceMappingURL=promise.js.map