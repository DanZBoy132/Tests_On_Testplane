"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertRgbaToPng = void 0;
const buffer_crc32_1 = require("buffer-crc32");
const node_zlib_1 = __importDefault(require("node:zlib"));
const png_1 = require("../constants/png");
const convertRgbaToScanlines = (rgba, width, height) => {
    const stride = width * png_1.RGBA_CHANNELS;
    const scanlines = Buffer.allocUnsafe(height * (1 + stride)); // extra byte for filter
    let scanlineOffset = 0;
    let pixelDataOffset = 0;
    for (let y = 0; y < height; y++) {
        scanlineOffset = scanlines.writeUInt8(png_1.PNG_FILTER_NO_FILTER, scanlineOffset);
        scanlineOffset += rgba.copy(scanlines, scanlineOffset, pixelDataOffset, pixelDataOffset + stride);
        pixelDataOffset += stride;
    }
    if (scanlineOffset !== scanlines.byteLength) {
        throw new Error("Got malformed input while trying to convert rgba to png");
    }
    return scanlines;
};
const convertRgbaToPng = (rgba, width, height, compressionLevel = 4) => {
    const scanlines = convertRgbaToScanlines(rgba, width, height);
    const compressedData = node_zlib_1.default.deflateSync(scanlines, { level: compressionLevel });
    const resultBuffer = Buffer.allocUnsafe(png_1.PNG_MIN_ASSIST_BYTES + compressedData.length);
    let pointer = 0;
    // signature
    pointer += png_1.PNG_SIGNATURE.copy(resultBuffer);
    // IHDR
    const ihdrPointer = (pointer = resultBuffer.writeUInt32BE(png_1.PNG_IHDR_LENGTH, pointer));
    pointer += resultBuffer.write("IHDR", pointer, "ascii");
    pointer = resultBuffer.writeUInt32BE(width, pointer);
    pointer = resultBuffer.writeUInt32BE(height, pointer);
    pointer = resultBuffer.writeUInt8(png_1.PNG_BIT_DEPTH_EIGHT_BIT, pointer);
    pointer = resultBuffer.writeUInt8(png_1.PNG_COLOR_TYPE_RGBA, pointer);
    pointer = resultBuffer.writeUInt8(png_1.PNG_COMPRESSION_DEFLATE, pointer);
    pointer = resultBuffer.writeUInt8(png_1.PNG_FILTER_NO_FILTER, pointer);
    pointer = resultBuffer.writeUInt8(png_1.PNG_INTERLACE_NO_INTERLACE, pointer);
    const ihdrCrc = (0, buffer_crc32_1.unsigned)(resultBuffer.subarray(ihdrPointer, pointer));
    pointer = resultBuffer.writeUInt32BE(ihdrCrc, pointer);
    // IDAT
    const idatPointer = (pointer = resultBuffer.writeUInt32BE(compressedData.length, pointer));
    pointer += resultBuffer.write("IDAT", idatPointer, "ascii");
    pointer += compressedData.copy(resultBuffer, pointer);
    const idatCrc = (0, buffer_crc32_1.unsigned)(resultBuffer.subarray(idatPointer, pointer));
    pointer = resultBuffer.writeUInt32BE(idatCrc, pointer);
    // IEND (empty)
    const iendPointer = (pointer = resultBuffer.writeUInt32BE(0, pointer));
    pointer += resultBuffer.write("IEND", pointer, "ascii");
    const iendCrc = (0, buffer_crc32_1.unsigned)(resultBuffer.subarray(iendPointer, pointer));
    pointer = resultBuffer.writeUInt32BE(iendCrc, pointer);
    if (pointer !== resultBuffer.byteLength) {
        throw new Error("Got malformed input while trying to convert rgba to png");
    }
    return resultBuffer;
};
exports.convertRgbaToPng = convertRgbaToPng;
//# sourceMappingURL=eight-bit-rgba-to-png.js.map